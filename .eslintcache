[{"/Users/interone/Downloads/webapps/ant-media-demo/src/index.js":"1","/Users/interone/Downloads/webapps/ant-media-demo/src/App.js":"2","/Users/interone/Downloads/webapps/ant-media-demo/src/reportWebVitals.js":"3","/Users/interone/Downloads/webapps/ant-media-demo/src/js/fetch.stream.js":"4","/Users/interone/Downloads/webapps/ant-media-demo/src/js/webrtc_adaptor.js":"5","/Users/interone/Downloads/webapps/ant-media-demo/src/js/peer_stats.js":"6","/Users/interone/Downloads/webapps/ant-media-demo/src/js/websocket_adaptor.js":"7"},{"size":500,"mtime":1609641348003,"results":"8","hashOfConfig":"9"},{"size":22001,"mtime":1609646599684,"results":"10","hashOfConfig":"9"},{"size":362,"mtime":1609641348004,"results":"11","hashOfConfig":"9"},{"size":3380,"mtime":1609643405836,"results":"12","hashOfConfig":"9"},{"size":42842,"mtime":1609646967529,"results":"13","hashOfConfig":"9"},{"size":3270,"mtime":1609642419288,"results":"14","hashOfConfig":"9"},{"size":4402,"mtime":1609642419292,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"1s7ajnz",{"filePath":"19","messages":"20","errorCount":0,"warningCount":38,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"18"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":67,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"18"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"18"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"35"},"/Users/interone/Downloads/webapps/ant-media-demo/src/index.js",[],["36","37"],"/Users/interone/Downloads/webapps/ant-media-demo/src/App.js",["38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75"],"import  { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport {WebRTCAdaptor} from \"./js/webrtc_adaptor.js\"\nimport {getUrlParameter} from \"./js/fetch.stream.js\" \nimport $ from \"jquery\";\n\nclass  App extends Component{\n  constructor(){\n    super();\n  }\n\n  componentDidMount(){\n\n    function init () {\n      var id = getUrlParameter(\"id\");\n      if(typeof id != \"undefined\") {\n      $(\"#streamName\").val(id);\n      }\n      else {\n      id = getUrlParameter(\"name\");\n      if (typeof id != \"undefined\") {\n        $(\"#streamName\").val(id);\n      } \n      else {\n        $(\"#streamName\").val(\"stream1\");\n      }\n      }\n      \n      $(\"#maxBandwidthTextBox\").val(maxVideoBitrateKbps);\n      $(\"#max_bandwidth_apply\").click(function() {\n      var bitrate = parseInt($(\"#maxBandwidthTextBox\").val());\n      if (bitrate == NaN || bitrate < 100 || bitrate > 2500) {\n        maxVideoBitrateKbps = 900;\n      }\n      else {\n        maxVideoBitrateKbps = bitrate;\n      }\n      console.log(\"input bitrate: \" + maxVideoBitrateKbps);\n      $(\"#maxBandwidthTextBox\").val(maxVideoBitrateKbps)\n      if (webRTCAdaptor != null) {\n        webRTCAdaptor.changeBandwidth(maxVideoBitrateKbps,  $(\"#streamName\").val());\n      }\n      })\n      }\n    $(function() {\n      init();\n  \n    });\n  \n    var maxVideoBitrateKbps = 900;\n  \n    //TODO: Migrate these methods to Jquery\n    var start_publish_button = document.getElementById(\"start_publish_button\");\n    start_publish_button.addEventListener(\"click\", startPublishing, false);\n    var stop_publish_button = document.getElementById(\"stop_publish_button\");\n    stop_publish_button.addEventListener(\"click\", stopPublishing, false);\n    var options = document.getElementById(\"options\");\n    options.addEventListener(\"click\", toggleOptions, false);\n    var send = document.getElementById(\"send\");\n    send.addEventListener(\"click\", sendData, false);\n    \n    document.getElementById(\"streamName\").defaultValue = \"Goofy\"\n    var streamNameBox = document.getElementById(\"streamName\");\n    streamNameBox.value = \"stream1\";\n    \n    /**\n     * If publishing stops for any reason, it tries to republish again.\n     */\n    var autoRepublishEnabled = true;\n    /**\n     * Timer job that checks the WebRTC connection \n     */\n    var autoRepublishIntervalJob = null;\n    \n    var streamId;\n    \n    var token = getUrlParameter(\"token\");\n    \n    // It should be true\n    var rtmpForward = getUrlParameter(\"rtmpForward\");\n  \n    function startPublishing() {\n      streamId = streamNameBox.value;\n      webRTCAdaptor.publish(streamId, token);\n    }\n  \n    function stopPublishing() {\n      if (autoRepublishIntervalJob != null) {\n        clearInterval(autoRepublishIntervalJob);\n        autoRepublishIntervalJob = null;\n      }\n      webRTCAdaptor.stop(streamId);\n    }\n    \n      function switchVideoMode(chbx) {\n        if(chbx.value == \"screen\") {\n          //webRTCAdaptor.switchDesktopWithMicAudio(streamId);\n          webRTCAdaptor.switchDesktopCapture(streamId);\n        }\n        else if(chbx.value == \"screen+camera\"){\n        webRTCAdaptor.switchDesktopCaptureWithCamera(streamId);\n      }\n      else {\n          webRTCAdaptor.switchVideoCameraCapture(streamId, chbx.value);\n        }\n    }\n      \n    function switchAudioMode(chbx) {\n      webRTCAdaptor.switchAudioInputSource(streamId, chbx.value);\n    }\n  \n    function getCameraRadioButton(deviceName, deviceId) {\n      return \"<div class=\\\"form-check form-check-inline\\\">\" + \t\n                \"<input class=\\\"form-check-input video-source\\\" name=\\\"videoSource\\\" type=\\\"radio\\\" value=\\\"\" + deviceId + \"\\\" id=\\\"\" + deviceId + \"\\\">\" +\n                \"<label class=\\\"form-check-label font-weight-light\\\" for=\\\"\" + deviceId + \"\\\" style=\\\"font-weight:normal\\\">\" +\n                  deviceName +\n                \"</label>\" +\t\t\n                 \"</div>\";\n    }\n  \n    function getAudioRadioButton(deviceName, deviceId) {\n      return \"<div class=\\\"form-check form-check-inline\\\">\" + \t\n                \"<input class=\\\"form-check-input audio-source\\\" name=\\\"audioSource\\\" type=\\\"radio\\\" value=\\\"\" + deviceId + \"\\\" id=\\\"\" + deviceId + \"\\\">\" +\n                \"<label class=\\\"form-check-label font-weight-light\\\" for=\\\"\" + deviceId + \"\\\" style=\\\"font-weight:normal\\\">\" +\n                  deviceName +\n                \"</label>\" +\t\t\n                 \"</div>\";\n    }\n  \n    function toggleOptions() {\n      $(\".options\").toggle();\n    }\n    \n    function sendData() {\n      try {\n        var iceState = webRTCAdaptor.iceConnectionState(streamId);\n              if (iceState != null && iceState != \"failed\" && iceState != \"disconnected\") {\n              \n          webRTCAdaptor.sendData($(\"#streamName\").val(), $(\"#dataTextbox\").val());\n          $(\"#dataMessagesTextarea\").append(\"Sent: \" + $(\"#dataTextbox\").val() + \"\\r\\n\");\n          $(\"#dataTextbox\").val(\"\");\n        }\n        else {\n          alert(\"WebRTC publishing is not active. Please click Start Publishing first\")\n        }\n      }\n      catch (exception) {\n        console.error(exception);\n        alert(\"Message cannot be sent. Make sure you've enabled data channel on server web panel\");\n      }\n    }\n      \n    \n    function checkAndRepublishIfRequired() {\n       var iceState = webRTCAdaptor.iceConnectionState(streamId);\n      console.log(\"Ice state checked = \" + iceState);\n  \n        if (iceState == null || iceState == \"failed\" || iceState == \"disconnected\"){\n          webRTCAdaptor.stop(streamId);\n          webRTCAdaptor.closePeerConnection(streamId);\n          webRTCAdaptor.closeWebSocket();\n          initWebRTCAdaptor(true, autoRepublishEnabled);\n        }\t\n    }\n  \n      function startAnimation() {\n  \n          $(\"#broadcastingInfo\").fadeIn(800, function () {\n            $(\"#broadcastingInfo\").fadeOut(800, function () {\n              var state = webRTCAdaptor.signallingState(streamId);\n              if (state != null && state != \"closed\") {\n                var iceState = webRTCAdaptor.iceConnectionState(streamId);\n                if (iceState != null && iceState != \"failed\" && iceState != \"disconnected\") {\n                    startAnimation();\n                }\n              }\n            });\n          });\n        }\n  \n    var pc_config = {\n        'iceServers' : [ {\n          'urls' : 'stun:stun1.l.google.com:19302'\n        } ]\n      };\n    /* \n    //sample turn configuration\n    {\n         iceServers: [\n                      { urls: \"\",\n                        username: \"\",\n                        credential: \"\",\n                      }\n                     ]\n      };\n      */\n  \n    var sdpConstraints = {\n      OfferToReceiveAudio : false,\n      OfferToReceiveVideo : false\n    };\n    \n    var mediaConstraints = {\n      video : true,\n      audio : true\n    };\n  \n    // var appName = window.location.pathname.substring(0, window.location.pathname.lastIndexOf(\"/\")+1);\n    var appName = '/LiveApp/'\n    var fpath = 'mediatest.1break.live'\n    var fport = 5443\n    var path =  fpath + \":\" + fport + appName + \"websocket?rtmpForward=\" + rtmpForward;\n    var websocketURL =  \"wss://\" + path;\n    debugger\n    if (window.location.protocol.startsWith(\"https\")) {\n      websocketURL = \"wss://\" + path;\n    }\n  \n    var\twebRTCAdaptor = null;\n    \n    function initWebRTCAdaptor(publishImmediately, autoRepublishEnabled) \n    {\n      webRTCAdaptor = new WebRTCAdaptor({\n          websocket_url : websocketURL,\n          mediaConstraints : mediaConstraints,\n          peerconnection_config : pc_config,\n          sdp_constraints : sdpConstraints,\n          localVideoId : \"localVideo\",\n          debug:true,\n          bandwidth:maxVideoBitrateKbps,\n          callback : (info, obj) => {\n            if (info == \"initialized\") {\n              console.log(\"initialized\");\n              start_publish_button.disabled = false;\n              stop_publish_button.disabled = true;\n              if (publishImmediately) {\n                webRTCAdaptor.publish(streamId, token)\n              }\n              \n            } else if (info == \"publish_started\") {\n              //stream is being published\n              console.log(\"publish started\");\n              start_publish_button.disabled = true;\n              stop_publish_button.disabled = false;\n              startAnimation();\n              if (autoRepublishEnabled && autoRepublishIntervalJob == null) \n              {\n                autoRepublishIntervalJob = setInterval(() => {\n                  checkAndRepublishIfRequired();\n                }, 3000);\n              }\n              webRTCAdaptor.enableStats(obj.streamId);\n            } else if (info == \"publish_finished\") {\n              //stream is being finished\n              console.log(\"publish finished\");\n              start_publish_button.disabled = false;\n              stop_publish_button.disabled = true;\n              $(\"#stats_panel\").hide();\n            }\n            else if (info == \"browser_screen_share_supported\") {\n              $(\".video-source\").prop(\"disabled\", false);\n              \n              console.log(\"browser screen share supported\");\n              // browser_screen_share_doesnt_support.style.display = \"none\";\n            }\n            else if (info == \"screen_share_stopped\") {\n              //choose the first video source. It may not be correct for all cases. \n              $(\".video-source\").first().prop(\"checked\", true);\t\n              console.log(\"screen share stopped\");\n            }\n            else if (info == \"closed\") {\n              //console.log(\"Connection closed\");\n              if (typeof obj != \"undefined\") {\n                console.log(\"Connecton closed: \" + JSON.stringify(obj));\n              }\n            }\n            else if (info == \"pong\") {\n              //ping/pong message are sent to and received from server to make the connection alive all the time\n              //It's especially useful when load balancer or firewalls close the websocket connection due to inactivity\n            }\n            else if (info == \"refreshConnection\") {\n              checkAndRepublishIfRequired();\n            }\n            else if (info == \"ice_connection_state_changed\") {\n              console.log(\"iceConnectionState Changed: \",JSON.stringify(obj));\n            }\n            else if (info == \"updated_stats\") {\n              //obj is the PeerStats which has fields\n               //averageOutgoingBitrate - kbits/sec\n              //currentOutgoingBitrate - kbits/sec\n              console.log(\"Average outgoing bitrate \" + obj.averageOutgoingBitrate + \" kbits/sec\"\n                  + \" Current outgoing bitrate: \" + obj.currentOutgoingBitrate + \" kbits/sec\"\n                  + \" video source width: \" + obj.resWidth + \" video source height: \" + obj.resHeight\n                  + \"frame width: \" + obj.frameWidth + \" frame height: \" + obj.frameHeight\n                  + \" video packetLost: \"  + obj.videoPacketsLost + \" audio packetsLost: \" + obj.audioPacketsLost\n                  + \" video RTT: \" + obj.videoRoundTripTime + \" audio RTT: \" + obj.audioRoundTripTime \n                  + \" video jitter: \" + obj.videoJitter + \" audio jitter: \" + obj.audioJitter);\n  \n                  \n              $(\"#average_bit_rate\").text(obj.averageOutgoingBitrate);\n              if (obj.averageOutgoingBitrate > 0)  {\n                $(\"#average_bit_rate_container\").show();\n              }\n              else {\n                $(\"#average_bit_rate_container\").hide();\n              }\n  \n              $(\"#latest_bit_rate\").text(obj.currentOutgoingBitrate);\n              if (obj.currentOutgoingBitrate > 0) {\n                $(\"#latest_bit_rate_container\").show();\n              }\n              else {\n                $(\"#latest_bit_rate_container\").hide();\n              }\n              var packetLost = parseInt(obj.videoPacketsLost) + parseInt(obj.audioPacketsLost);\t\n              \n              $(\"#packet_lost_text\").text(packetLost);\n              if (packetLost > -1) {\n                $(\"#packet_lost_container\").show();\n              }\n              else {\n                $(\"#packet_lost_container\").hide();\n              }\n              var jitter = ((parseFloat(obj.videoJitter) + parseInt(obj.audioJitter)) / 2).toPrecision(3);\n              $(\"#jitter_text\").text(jitter);\n              if (jitter > 0) {\n                $(\"#jitter_container\").show();\n              }\n              else {\n                $(\"#jitter_container\").hide();\n              }\n            \n              var rtt = ((parseFloat(obj.videoRoundTripTime) + parseFloat(obj.audioRoundTripTime)) / 2).toPrecision(3);\n              $(\"#round_trip_time\").text(rtt);\n              if (rtt > 0) {\n                $(\"#round_trip_time_container\").show();\n              }\n              else {\n                $(\"#round_trip_time_container\").hide();\n              }\n              \n              $(\"#source_width\").text(obj.resWidth);\n              $(\"#source_height\").text(obj.resHeight);\n              if (obj.resWidth > 0 && obj.resHeight > 0) {\n                $(\"#source_resolution_container\").show();\n              }\n              else {\n                $(\"#source_resolution_container\").hide();\n              }\n  \n              $(\"#ongoing_width\").text(obj.frameWidth);\n              $(\"#ongoing_height\").text(obj.frameHeight);\t\n              if (obj.frameWidth > 0 && obj.frameHeight > 0) {\n                $(\"#ongoing_resolution_container\").show();\n              }\n              else {\n                $(\"#ongoing_resolution_container\").hide();\n              }\n              \n              $(\"#on_going_fps\").text(obj.currentFPS);\n              if (obj.currentFPS > 0) {\n                $(\"#on_going_fps_container\").show();\n              }\n              else {\n                $(\"#on_going_fps_container\").hide();\n              }\n  \n              $(\"#stats_panel\").show();\n    \n            }\n            else if (info == \"data_received\") {\n              console.log(\"Data received: \" + obj.event.data + \" type: \" + obj.event.type + \" for stream: \" + obj.streamId);\n              $(\"#dataMessagesTextarea\").append(\"Received: \" + obj.event.data + \"\\r\\n\");\n            }\n            else if (info == \"available_devices\") {\n              var videoHtmlContent = \"\";\n              var audioHtmlContent = \"\";\n              obj.forEach(function(device) {\n                if (device.kind == \"videoinput\") {\n                  videoHtmlContent += getCameraRadioButton(device.label, device.deviceId);\n                }\n                else if (device.kind == \"audioinput\"){\n                  audioHtmlContent += getAudioRadioButton(device.label, device.deviceId);\n                }\n              }); \n              $(videoHtmlContent).insertAfter(\".video-source-legend\");\n              $(\".video-source\").first().prop(\"checked\", true);\t\n              \n              $(audioHtmlContent).insertAfter(\".audio-source-legend\");\n              $(\".audio-source\").first().prop(\"checked\", true);\t\n  \n              if (document.querySelector('input[name=\"videoSource\"]')) {\n                document.querySelectorAll('input[name=\"videoSource\"]').forEach((elem) => {\n                  elem.addEventListener(\"change\", function(event) {\n                  var item = event.target;\n                  switchVideoMode(item)\n                  });\n                  });\n              }\n              if (document.querySelector('input[name=\"audioSource\"]')) {\n                document.querySelectorAll('input[name=\"audioSource\"]').forEach((elem) => {\n                  elem.addEventListener(\"change\", function(event) {\n                  var item = event.target;\n                  switchAudioMode(item)\n                  });\n                  });\n              }\n            }\n            else {\n              console.log( info + \" notification received\");\n            }\n          },\n          callbackError : function(error, message) {\n            //some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError\n            debugger\n            console.log(\"error callback: \" +  JSON.stringify(error));\n            var errorMessage = JSON.stringify(error);\n            if (typeof message != \"undefined\") {\n              errorMessage = message;\n            }\n            var errorMessage = JSON.stringify(error);\n            if (error.indexOf(\"NotFoundError\") != -1) {\n              errorMessage = \"Camera or Mic are not found or not allowed in your device\";\n            }\n            else if (error.indexOf(\"NotReadableError\") != -1 || error.indexOf(\"TrackStartError\") != -1) {\n              errorMessage = \"Camera or Mic is being used by some other process that does not let read the devices\";\n            }\n            else if(error.indexOf(\"OverconstrainedError\") != -1 || error.indexOf(\"ConstraintNotSatisfiedError\") != -1) {\n              errorMessage = \"There is no device found that fits your video and audio constraints. You may change video and audio constraints\"\n            }\n            else if (error.indexOf(\"NotAllowedError\") != -1 || error.indexOf(\"PermissionDeniedError\") != -1) {\n              errorMessage = \"You are not allowed to access camera and mic.\";\n            }\n            else if (error.indexOf(\"TypeError\") != -1) {\n              errorMessage = \"Video/Audio is required\";\n            }\n            else if (error.indexOf(\"ScreenSharePermissionDenied\") != -1) {\n              errorMessage = \"You are not allowed to access screen share\";\n              $(\".video-source\").first().prop(\"checked\", true);\t\t\t\t\t\t\n            }\n            else if (error.indexOf(\"WebSocketNotConnected\") != -1) {\n              errorMessage = \"WebSocket Connection is disconnected.\";\n            }\n            alert(errorMessage);\n          }\n        });\n    }\n    \n    //initialize the WebRTCAdaptor\n    initWebRTCAdaptor(false, autoRepublishEnabled);\n  }\n\n  render(){\n    return(\n      <div class=\"jumbotron\">\n\t\t\t<div class=\"col-sm-12 form-group\">\n\t\t\t\t<video id=\"localVideo\"  autoplay muted controls playsinline></video>\n\t\t\t</div>\n\t\t\t<div class=\"form-group col-sm-12 text-left\">\n\t\t\t\t<input type=\"text\" class=\"form-control\"\n\t\t\t\t\t\tid=\"streamName\" name=\"streamIdTextBox\" placeholder=\"Type stream name\"/>\n\t\t\t</div>\n\t\t\t<div class=\"col-sm-12 text-right\">\n\t\t\t\t<button type=\"button\" id=\"options\" class=\"btn btn-outline-primary btn-sm\" >Options</button>\n\t\t\t</div>\n\t\t\t<div class=\"form-group col-sm-12 text-left options\">\n\t\t\t\t\n\t\t\t\t<label class=\" mr-2\" for=\"inlineFormCustomSelectPref\">Max Video Bitrate(Kbps):</label>\n\t\t\t\t<div class=\"form-inline\">\n\t\t\t\t\t<input type=\"text\" class=\"form-control  mr-sm-2\"\n\t\t\t\t\t\t\tid=\"maxBandwidthTextBox\" name=\"maxBandwidthTextBox\" />\n\t\t\t\t  \n\t\t\t\t\t<button type=\"button\" class=\"btn btn-outline-primary btn-sm\" id=\"max_bandwidth_apply\" >Apply</button>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"dropdown-divider\"></div>\n\t\t\t\t<legend class=\"col-form-label video-source-legend\">Video Source</legend>\n\t\n\t\t\t\t<div class=\"form-check form-check-inline\">\t\n\t\t\t\t\t<input class=\"form-check-input video-source\" disabled name=\"videoSource\" type=\"radio\" value=\"screen\" \n\t\t\t\t\tid=\"screen_share_checkbox\"/>\n\t\t\t\t\t<label class=\"form-check-label font-weight-light\" for=\"screen_share_checkbox\" >\n\t\t\t\t\t\t\tScreen\n\t\t\t\t\t</label>\n\t\t\t\t</div>\n\t\t\t\t\n\t\t\t\t<div class=\"form-check form-check-inline\">\n\t\t\t\t\t<input class=\"form-check-input video-source\" disabled name=\"videoSource\" type=\"radio\" value=\"screen+camera\" \n\t\t\t\t\t\tid=\"screen_share_with_camera_checkbox\"/>\n\t\t\t\t\t<label class=\"form-check-label font-weight-light\" for=\"screen_share_with_camera_checkbox\" >\n\t\t\t\t\t\t\tScreen with Camera\n\t\t\t\t\t</label>\n\t\t\t\t\t\t{/* <a id=\"browser_screen_share_doesnt_support\" href=\"https://caniuse.com/#search=getDisplayMedia\">Your browser doesn't support screen share. You can see supported browsers in this link </a> */}\n\t\t\t\t</div>\n\t\t\t\t<div class=\"dropdown-divider\"></div>\n\t\t\t\t<legend class=\"col-form-label audio-source-legend\">Audio Source</legend>\n\t\t\t\t\n\t\t\t</div>\t\n\t\t\t<div class=\"dropdown-divider\"></div>\n\t\t\t<div class=\"form-group col-sm-12 text-left options\">\n\t\t\t\t<label>Data Channel Messages</label>\n\t\t\t\t<textarea class=\"form-control\" id=\"dataMessagesTextarea\" rows=\"8\"></textarea>\n\t\t\t\t<div class=\"form-row\">\n\t\t\t\t\t<div class=\"form-group col-sm-10\">\n\t\t\t\t\t\t<input type=\"text\" class=\"form-control\" id=\"dataTextbox\" placeholder=\"Write your message to send players\"/>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"form-group col-sm-2\">\n\t\t\t\t\t<button type=\"button\" id=\"send\" class=\"btn btn-outline-primary btn-block\">Send</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t\t\t\n\n\t\t\t\t<div class=\"form-group\">\t\n\t\t\t\t\t<button class=\"btn btn-primary\" disabled\n\t\t\t\t\tid=\"start_publish_button\">Start Publishing</button>\n\t\t\t\t\t<button class=\"btn btn-primary\" disabled\n\t\t\t\t\tid=\"stop_publish_button\">Stop Publishing</button>\n\t\t\t\t</div>\t\t\t\n\n\t\t\t\t<span class=\"badge badge-success\" id=\"broadcastingInfo\" >Publishing</span>\n\t\t\t\t<div class=\"dropdown-divider\"></div>\t\t\t\n\t\t\t\t<div class=\"col-sm-10 offset-sm-1\" id=\"stats_panel\" >\n\t\t\t\t\t<div class=\"row text-muted text-left\">\n\t\t\t\t\t  <div class=\"col-sm-6\">\n\t\t\t\t\t\t<small>\n\t\t\t\t\t\t <div id=\"average_bit_rate_container\">Average Bitrate(Kbps): <span id=\"average_bit_rate\"></span></div>\n\t\t\t\t\t\t <div id=\"latest_bit_rate_container\">Latest Bitrate(Kbps): <span id=\"latest_bit_rate\"></span></div>\n\t\t\t\t\t\t <div id=\"packet_lost_container\">PacketsLost: <span id=\"packet_lost_text\"></span></div>\n\t\t\t\t\t\t <div id=\"jitter_text_container\">Jitter(Secs): <span id=\"jitter_text\"></span></div>\n\t\t\t\t\t\t</small>\n\t\t\t\t\t  </div>\n\t\t\t\t\t  <div class=\"col-sm-6\">\n\t\t\t\t\t\t<small>\n\t\t\t\t\t\t<div id=\"round_trip_time_container\">Round Trip Time(Secs): <span id=\"round_trip_time\"></span></div>\n\t\t\t\t\t\t<div id=\"source_resolution_container\">Source WidthxHeight: <span id=\"source_width\"></span> x <span id=\"source_height\"></span></div>\n\t\t\t\t\t\t<div id=\"ongoing_resolution_container\">On-going WidthxHeight: <span id=\"ongoing_width\"></span> x <span id=\"ongoing_height\"></span></div>\n\t\t\t\t\t\t<div id=\"on_going_fps_container\">On-going FPS: <span id=\"on_going_fps\"></span></div>\n\t\t\t\t\t\t\n\t\t\t\t\t\t</small>\n\t\t\t\t\t  </div>\n\t\t\t\t\t</div>\n\t\t\t\t  </div>\n\t\t\t\t\n\n\t\t</div>\n    )\n  }\n}\nexport default App;\n","/Users/interone/Downloads/webapps/ant-media-demo/src/reportWebVitals.js",[],"/Users/interone/Downloads/webapps/ant-media-demo/src/js/fetch.stream.js",[],"/Users/interone/Downloads/webapps/ant-media-demo/src/js/webrtc_adaptor.js",["76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142"],"/**\n *\n * @returns\n */\n\nimport {PeerStats} from \"./peer_stats.js\"\nimport {WebSocketAdaptor} from \"./websocket_adaptor.js\"\nimport adapter from 'webrtc-adapter';\nexport class WebRTCAdaptor\n{\n\tconstructor(initialValues){\n\t\tthis.peerconnection_config = null;\n\t\tthis.sdp_constraints = null;\n\t\tthis.remotePeerConnection = new Array();\n\t\tthis.remotePeerConnectionStats = new Array();\n\t\tthis.remoteDescriptionSet = new Array();\n\t\tthis.iceCandidateList = new Array();\n\t\tthis.roomName = null;\n\t\tthis.videoTrackSender = null;\n\t\tthis.audioTrackSender = null;\n\t\tthis.playStreamId = new Array();\n\t\tthis.micGainNode = null;\n\t\tthis.localStream = null;\n\t\tthis.bandwidth = 900; //default bandwidth kbps\n\t\tthis.isMultiPeer = false; //used for multiple peer client\n\t\tthis.multiPeerStreamId = null;   //used for multiple peer client\n\t\tthis.roomTimerId = -1;\n\t\tthis.isWebSocketTriggered = false;\n\t\tthis.webSocketAdaptor = null;\n\t\tthis.isPlayMode = false;\n\t\tthis.debug = false;\n\t\tthis.composedStream = new MediaStream();\n\n\t\tthis.publishMode=\"camera\"; //screen, screen+camera\n\n\t\t/**\n\t\t * Supported candidate types. Below types are for both sending and receiving candidates.\n\t\t * It means if when client receives candidate from STUN server, it sends to the server if candidate's protocol\n\t\t * is in the list. Likely, when client receives remote candidate from server, it adds as ice candidate\n\t\t * if candidate protocol is in the list below.\n\t\t */\n\t\tthis.candidateTypes = [\"udp\", \"tcp\"];\n\n\n\t\tthis.desktopStream = null;\n\n\t\t/**\n\t\t * The cam_location below is effective when camera and screen is send at the same time.\n\t\t * possible values are top and bottom. It's on right all the time\n\t\t */\n\t\tthis.camera_location = \"top\"\n\n\t\t/**\n\t\t * The cam_margin below is effective when camera and screen is send at the same time.\n\t\t * This is the margin value in px from the edges\n\t\t */\n\t\tthis.camera_margin = 15;\n\n\t\t/**\n\t\t * this camera_percent is how large the camera view appear on the screen. It's %15 by default.\n\t\t */\n\t\tthis.camera_percent = 15;\n\n\t\tfor(var key in initialValues) {\n\t\t\tif(initialValues.hasOwnProperty(key)) {\n\t\t\t\tthis[key] = initialValues[key];\n\t\t\t}\n\t\t}\n\n\t\tthis.localVideo = document.getElementById(this.localVideoId);\n\t\tthis.remoteVideo = document.getElementById(this.remoteVideoId);\n\n\t\t// It should be compatible with previous version\n\t\tif(this.mediaConstraints.video == \"camera\") {\n\t\t\tthis.publishMode=\"camera\";\n\t\t}\n\t\telse if(this.mediaConstraints.video == \"screen\") {\n\t\t\tthis.publishMode=\"screen\";\n\t\t}\n\t\telse if(this.mediaConstraints.video == \"screen+camera\") {\n\t\t\tthis.publishMode=\"screen+camera\";\n\t\t}\n\n\t\tif (!(\"WebSocket\" in window)) {\n\t\t\tconsole.log(\"WebSocket not supported.\");\n\t\t\tthis.callbackError(\"WebSocketNotSupported\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof navigator.mediaDevices == \"undefined\" && this.isPlayMode == false) {\n\t\t\tconsole.log(\"Cannot open camera and mic because of unsecure context. Please Install SSL(https)\");\n\t\t\tthis.callbackError(\"UnsecureContext\");\n\t\t\treturn;\n\t\t}\t\t\n\t\t/*\n\t\t* Check browser support for screen share feature.\n\t\t*/\n\t\tthis.checkBrowserScreenShareSupported();\n\n\t\tif (!this.isPlayMode && typeof this.mediaConstraints != \"undefined\" && this.localStream == null)\n\t\t{\n\t\t\tif (typeof this.mediaConstraints.video != \"undefined\" && this.mediaConstraints.video != false)\n\t\t\t{\n\t\t\t\tthis.openStream(this.mediaConstraints, this.mode);\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// get only audio\n\t\t\t\tvar media_audio_constraint = { audio: this.mediaConstraints.audio };\n\t\t\t\tthis.navigatorUserMedia(media_audio_constraint , stream => {\n\t\t\t\t\tthis.gotStream(stream);\n\t\t\t\t}, true)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t//just playing, it does not open any stream\n\t\t\tif (this.webSocketAdaptor == null || this.webSocketAdaptor.isConnected() == false) {\n\t\t\t\tthis.webSocketAdaptor = new WebSocketAdaptor({websocket_url : this.websocket_url, webrtcadaptor : this, callback : this.callback, callbackError : this.callbackError});\n\t\t\t}\n\t\t}\n\t}\n\tsetDesktopwithCameraSource(stream, streamId, audioStream, onEndedCallback) \n\t{\n\t\tthis.desktopStream = stream;\n\t\tthis.navigatorUserMedia({video: true, audio: false},cameraStream => {\n\n\t\t\t//create a canvas element\n\t\t\tvar canvas = document.createElement(\"canvas\");\n\t\t\tvar canvasContext = canvas.getContext(\"2d\");\n\n\t\t\t//create video element for screen\n\t\t\t//var screenVideo = document.getElementById('sourceVideo');\n\t\t\tvar screenVideo = document.createElement('video');\n\n\t\t\tscreenVideo.srcObject = stream;\n\t\t\tscreenVideo.play();\n\t\t\t//create video element for camera\n\t\t\tvar cameraVideo = document.createElement('video');\n\n\t\t\tcameraVideo.srcObject = cameraStream;\n\t\t\tcameraVideo.play();\n\t\t\tvar canvasStream = canvas.captureStream(15);\n\n\t\t\tif(this.localStream == null){\n\t\t\t\tthis.gotStream(canvasStream);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis.updateVideoTrack(canvasStream,streamId,this.mediaConstraints,onended,null);\n\t\t\t}\n\t\t\tif (onEndedCallback != null) {\n\t\t\t\tstream.getVideoTracks()[0].onended = function(event) {\n\t\t\t\t\tonEndedCallback(event);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//update the canvas\n\t\t\tsetInterval(() => {\n\t\t\t\t//draw screen to canvas\n\t\t\t\tcanvas.width = screenVideo.videoWidth;\n\t\t\t\tcanvas.height = screenVideo.videoHeight;\n\t\t\t\tcanvasContext.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);\n\n\t\t\t\tvar cameraWidth = screenVideo.videoWidth * (this.camera_percent/100);\n\t\t\t\tvar cameraHeight = (cameraVideo.videoHeight/cameraVideo.videoWidth)*cameraWidth\n\n\t\t\t\tvar positionX = (canvas.width - cameraWidth) - this.camera_margin;\n\t\t\t\tvar positionY;\n\n\t\t\t\tif (this.camera_location == \"top\") {\n\t\t\t\t\tpositionY = this.camera_margin;\n\t\t\t\t}\n\t\t\t\telse { //if not top, make it bottom\n\t\t\t\t\t//draw camera on right bottom corner\n\t\t\t\t\tpositionY = (canvas.height - cameraHeight) - this.camera_margin;\n\t\t\t\t}\n\t\t\t\tcanvasContext.drawImage(cameraVideo, positionX, positionY, cameraWidth, cameraHeight);\n\t\t\t}, 66);\n\t\t}, true)\n\t}\n\tgetDevices(){\n\t\tnavigator.mediaDevices.enumerateDevices().then(devices => {\n\t\t\tlet deviceArray = new Array();\n\t\t\tlet checkAudio = false\n\t\t\tdevices.forEach(device => {\t\n\t\t\t\tif (device.kind == \"audioinput\" || device.kind == \"videoinput\") {\n\t\t\t\t\tdeviceArray.push(device);\n\t\t\t\t\tif(device.kind==\"audioinput\"){\n\t\t\t\t\t\tcheckAudio = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.callback(\"available_devices\", deviceArray);\n\t\t\tif(checkAudio == false && this.localStream == null){\n\t\t\t\tconsole.log(\"Audio input not found\")\n\t\t\t\tconsole.log(\"Retrying to get user media without audio\")\n\t\t\t\tthis.openStream({video : true, audio : false}, this.mode)\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tconsole.error(\"Cannot get devices -> error name: \" + err.name + \": \" + err.message);\n\t\t});\n\t}\n\n\tprepareStreamTracks(mediaConstraints,audioConstraint,stream,streamId) \n\t{\n\t\t//this trick, getting audio and video separately, make us add or remove tracks on the fly\n\t\tvar audioTrack = stream.getAudioTracks()\n\t\tif (audioTrack.length > 0 && this.publishMode == \"camera\") {\n\t\t\taudioTrack[0].stop();\n\t\t\tstream.removeTrack(audioTrack[0]);\n\t\t}\n\t\t//now get only audio to add this stream\n\t\tif (audioConstraint != \"undefined\" && audioConstraint != false) {\n\t\t\tvar media_audio_constraint = { audio: audioConstraint};\n\t\t\tthis.navigatorUserMedia(media_audio_constraint, audioStream => {\n\n\t\t\t\t//add callback if desktop is sharing\n\t\t\t\tvar onended = event => {\n\t\t\t\t\tthis.callback(\"screen_share_stopped\");\n\t\t\t\t\tthis.setVideoCameraSource(streamId, mediaConstraints, null, true);\n\t\t\t\t}\n\n\t\t\t\tif(this.publishMode == \"screen\"){\n\t\t\t\t\tthis.updateVideoTrack(stream,streamId,mediaConstraints,onended,true);\n\t\t\t\t\tif(audioTrack.length > 0 ){\n\t\t\t\t\t\tthis.captureScreenSound(stream, audioStream, streamId);\n\t\t\t\t\t\tthis.updateAudioTrack(this.composedStream,streamId,null);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tthis.updateAudioTrack(audioStream,streamId,null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(this.publishMode == \"screen+camera\" ){\n\t\t\t\t\tif(audioTrack.length > 0 ){\n\t\t\t\t\t\tthis.captureScreenSound(stream, audioStream, streamId);\n\t\t\t\t\t\tthis.updateAudioTrack(this.composedStream,streamId,null);\n\t\t\t\t\t\tthis.setDesktopwithCameraSource(stream,streamId,this.composedStream,onended);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tthis.updateAudioTrack(audioStream,streamId,null);\n\t\t\t\t\t\tthis.setDesktopwithCameraSource(stream,streamId,audioStream,onended);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(audioConstraint != false && audioConstraint != undefined){\n\t\t\t\t\t\tstream.addTrack(audioStream.getAudioTracks()[0]);\n\t\t\t\t\t}\n\t\t\t\t\tthis.gotStream(stream);\n\t\t\t\t}\n\t\t\t}, true)\n\t\t}\n\t\telse {\n\t\t\t// if(typeof audioStream != \"undefined\" && audioStream.getAudioTracks()[0] != null){\n\t\t\t// \tstream.addTrack(audioStream.getAudioTracks()[0]);\n\t\t\t// }\n\t\t\tthis.gotStream(stream);\n\t\t}\n\t}\n\n\tnavigatorUserMedia(mediaConstraints, func ,catch_error)\n\t{\n\t\tif( catch_error == true){\n\t\tnavigator.mediaDevices.getUserMedia(mediaConstraints).then(func).catch(error => {\n\t\t\tif (error.name == \"NotFoundError\"){\n\t\t\t\tthis.getDevices()\n\t\t\t}else{\n\t\t\t\tthis.callbackError(error.name, error.message);\n\t\t\t}\n\t\t\t});\n\t\t}else {\n\t\t\tnavigator.mediaDevices.getUserMedia(mediaConstraints).then(func)\n\t\t}\n\t}\n\n\t/**\n\t * Get user media\n\t */\n\tgetUserMedia(mediaConstraints, audioConstraint, streamId) \n\t{\n\t\t// Check Media Constraint video value screen or screen + camera\n\t\tif(this.publishMode == \"screen+camera\" || this.publishMode == \"screen\"){\n\t\t\tnavigator.mediaDevices.getDisplayMedia(mediaConstraints)\n\t\t\t.then(stream =>{\n\t\t\t\tthis.prepareStreamTracks(mediaConstraints,audioConstraint,stream, streamId);\n\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tif (error.name === \"NotAllowedError\") {\n\t\t\t\t\tconsole.debug(\"Permission denied error\");\n\t\t\t\t\tthis.callbackError(\"ScreenSharePermissionDenied\");\n\n\t\t\t\t\t// Redirect Default Stream Camera\n\t\t\t\t\tif(this.localStream == null){\n\n\t\t\t\t\t\tvar mediaConstraints = {\n\t\t\t\t\t\t\tvideo : true,\n\t\t\t\t\t\t\taudio : true\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.openStream(mediaConstraints);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tthis.switchVideoCameraCapture(streamId);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t// If mediaConstraints only user camera\n\t\telse {\n\t\t\tthis.navigatorUserMedia(mediaConstraints, (stream =>{\n\t\t\t\tthis.prepareStreamTracks(mediaConstraints,audioConstraint,stream, streamId);\n\t\t\t}),true);\n\t\t}\n\t}\n\n\t/**\n\t * Open media stream, it may be screen, camera or audio\n\t */\n\topenStream(mediaConstraints)\n\t{\n\t\tthis.mediaConstraints = mediaConstraints;\n\t\tvar audioConstraint = false;\n\t\tif (typeof mediaConstraints.audio != \"undefined\" && mediaConstraints.audio != false) {\n\t\t\taudioConstraint = mediaConstraints.audio;\n\t\t}\n\n\t\tif (typeof mediaConstraints.video != \"undefined\") {\n\t\t\tthis.getUserMedia(mediaConstraints, audioConstraint);\n\t\t}\n\t\telse {\n\t\t\tconsole.error(\"MediaConstraint video is not defined\");\n\t\t\tthis.callbackError(\"media_constraint_video_not_defined\");\n\t\t}\n\t}\n\n\t/**\n\t * Closes stream, if you want to stop peer connection, call stop(streamId)\n\t */\n\tcloseStream() \n\t{\n\t\tthis.localStream.getVideoTracks().forEach(function(track) {\n\t\t\ttrack.onended = null;\n\t\t\ttrack.stop();\n\t\t});\n\n\t\tthis.localStream.getAudioTracks().forEach(function(track) {\n\t\t\ttrack.onended = null;\n\t\t\ttrack.stop();\n\t\t});\n\t}\n\n\t/**\n\t * Checks browser supports screen share feature\n\t * if exist it calls callback with \"browser_screen_share_supported\"\n\t */\n\n\tcheckBrowserScreenShareSupported() \n\t{\n\t\tif ((typeof navigator.mediaDevices != \"undefined\"  && navigator.mediaDevices.getDisplayMedia) || navigator.getDisplayMedia ) {\n\t\t\tthis.callback(\"browser_screen_share_supported\");\n\t\t}\n\t};\n\n\tenableMicInMixedAudio(enable) \n\t{\n\t\tif (this.micGainNode != null) {\n\t\t\tif (enable) {\n\t\t\t\tthis.micGainNode.gain.value = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.micGainNode.gain.value = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublish(streamId, token) \n\t{\n\t\t//If it started with playOnly mode and wants to publish now\n\t\tif(this.localStream == null){\n\t\t\tthis.navigatorUserMedia(this.mediaConstraints, (stream => {\n\t\t\t\tthis.gotStream(stream);\n\t\t\t\tvar jsCmd = {\n\t\t\t\t\tcommand : \"publish\",\n\t\t\t\t\tstreamId : streamId,\n\t\t\t\t\ttoken : token,\n\t\t\t\t\tvideo: this.localStream.getVideoTracks().length > 0 ? true : false,\n\t\t\t\t\t\t\taudio: this.localStream.getAudioTracks().length > 0 ? true : false,\n\t\t\t\t};\n\t\t\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t\t\t}), false);\n\t\t}else{\n\t\t\tvar jsCmd = {\n\t\t\t\t\tcommand : \"publish\",\n\t\t\t\t\tstreamId : streamId,\n\t\t\t\t\ttoken : token,\n\t\t\t\t\tvideo: this.localStream.getVideoTracks().length > 0 ? true : false,\n\t\t\t\t\t\t\taudio: this.localStream.getAudioTracks().length > 0 ? true : false,\n\t\t\t};\n\t\t}\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\n\tjoinRoom(roomName, streamId) \n\t{\n\t\tthis.roomName = roomName;\n\n\t\tvar jsCmd = {\n\t\t\t\tcommand : \"joinRoom\",\n\t\t\t\troom: roomName,\n\t\t\t\tstreamId: streamId,\n\t\t}\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\n\tplay(streamId, token, roomId, enableTracks) \n\t{\n\t\tthis.playStreamId.push(streamId);\n\t\tvar jsCmd =\n\t\t{\n\t\t\t\tcommand : \"play\",\n\t\t\t\tstreamId : streamId,\n\t\t\t\ttoken : token,\n\t\t\t\troom : roomId,\n\t\t\t\ttrackList : enableTracks,\n\t\t}\n\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\n\tstop(streamId) \n\t{\n\t\tthis.closePeerConnection(streamId);\n\n\t\tvar jsCmd = {\n\t\t\t\tcommand : \"stop\",\n\t\t\t\tstreamId: streamId,\n\t\t};\n\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\n\tjoin(streamId) \n\t{\n\t\tvar jsCmd = {\n\t\t\t\tcommand : \"join\",\n\t\t\t\tstreamId : streamId,\n\t\t\t\tmultiPeer : this.isMultiPeer && this.multiPeerStreamId == null,\n\t\t\t\tmode : this.isPlayMode ? \"play\" : \"both\",\n\t\t};\n\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\n\tleaveFromRoom(roomName) \n\t{\n\t\tthis.roomName = roomName;\n\t\tvar jsCmd = {\n\t\t\t\tcommand : \"leaveFromRoom\",\n\t\t\t\troom: roomName,\n\t\t};\n\t\tconsole.log (\"leave request is sent for \"+ roomName);\n\t\t\n\t\tif ( this.roomTimerId != null)\n\t\t{\n\t\t\tclearInterval(this.roomTimerId);\n\t\t}\n\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\n\tleave(streamId) \n\t{\n\t\tvar jsCmd = {\n\t\t\t\tcommand : \"leave\",\n\t\t\t\tstreamId: this.isMultiPeer && this.multiPeerStreamId != null ? this.multiPeerStreamId : streamId,\n\t\t};\n\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t\tthis.closePeerConnection(streamId);\n\t\tthis.multiPeerStreamId = null;\n\t}\n\n\tgetStreamInfo(streamId) \n\t{\n\t\tvar jsCmd = {\n\t\t\t\tcommand : \"getStreamInfo\",\n\t\t\t\tstreamId: streamId,\n\t\t};\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\t\n\tgetRoomInfo(roomName,streamId) \n\t{\n\t\tthis.roomTimerId = setInterval(() => {\n\t\t\tvar jsCmd = {\n\t\t\t\tcommand : \"getRoomInfo\",\n\t\t\t\tstreamId : streamId,\n\t\t\t\troom: roomName,\n\t\t};\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t\t}, 5000);\n\t}\n\n\tenableTrack(mainTrackId, trackId, enabled) \n\t{\n\t\tvar jsCmd = {\n\t\t\t\tcommand : \"enableTrack\",\n\t\t\t\tstreamId : mainTrackId,\n\t\t\t\ttrackId : trackId,\n\t\t\t\tenabled : enabled,\n\t\t};\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\n\tgetTracks(streamId, token) \n\t{\n\t\tthis.playStreamId.push(streamId);\n\t\tvar jsCmd =\n\t\t{\n\t\t\t\tcommand : \"getTrackList\",\n\t\t\t\tstreamId : streamId,\n\t\t\t\ttoken : token,\n\t\t}\n\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\n\tgotStream(stream)\n\t{\n\t\tthis.localStream = stream;\n\t\tthis.localVideo.srcObject = stream;\n\t\t\n\t\tif (this.webSocketAdaptor == null || this.webSocketAdaptor.isConnected() == false) {\n\t\t\tthis.webSocketAdaptor = new WebSocketAdaptor({websocket_url : this.websocket_url, webrtcadaptor : this, callback : this.callback, callbackError : this.callbackError})\n\t\t}\n\t\tthis.getDevices()\n\t};\n\tswitchDesktopCapture(streamId){\n\t\tthis.publishMode = \"screen\";\n\n\t\tvar audioConstraint = false;\n\t\tif (typeof this.mediaConstraints.audio != \"undefined\" && this.mediaConstraints.audio != false) {\n\t\t\taudioConstraint = this.mediaConstraints.audio;\n\t\t}\n\n\t\tthis.getUserMedia(this.mediaConstraints, audioConstraint, streamId);\n\t}\n\t/*\n\t* This method captures the sound of desktop and merge it with the sound of microphone. \n\t* Gain values can be adjusted in the merged sound. composedStream is the merged sound stream.\n\t*/\n\tcaptureScreenSound(stream, micStream,streamId)\n\t{\n\t\t//console.debug(\"audio stream track count: \" + audioStream.getAudioTracks().length);\n\t\tvar composedStream = new MediaStream();\n\t\t//added the video stream from the screen\n\t\tstream.getVideoTracks().forEach(function(videoTrack) {\n\t\t\tcomposedStream.addTrack(videoTrack);\n\t\t});\n\n\t\tvar audioContext = new AudioContext();\n\t\tvar desktopSoundGainNode = audioContext.createGain();\n\n\t\t//Adjust the gain for screen sound\n\t\tdesktopSoundGainNode.gain.value = 1;\n\n\t\tvar audioDestionation = audioContext.createMediaStreamDestination();\n\t\tvar audioSource = audioContext.createMediaStreamSource(stream);\n\n\t\taudioSource.connect(desktopSoundGainNode).connect(audioDestionation);;\n\n\t\tthis.micGainNode = audioContext.createGain();\n\t\t\n\t\t//Adjust the gain for microphone sound\n\t\tthis.micGainNode.gain.value = 0;\n\n\t\tvar audioSource2 = audioContext.createMediaStreamSource(micStream);\n\t\taudioSource2.connect(this.micGainNode).connect(audioDestionation);;\n\n\t\taudioDestionation.stream.getAudioTracks().forEach(function(track) {\n\t\t\tcomposedStream.addTrack(track);\n\t\t});\n\t\tthis.composedStream = composedStream;\n\t}\n\n\tswitchAudioInputSource(streamId, deviceId) \n\t{\n\t\t//stop the track because in some android devices need to close the current camera stream\n\t\tvar audioTrack = this.localStream.getAudioTracks()[0];\n\t\tif (audioTrack) {\n\t\t\taudioTrack.stop();\n\t\t}\n\t\telse {\n\t\t   console.warn(\"There is no audio track in local stream\");\n\t\t}\n\n\t\tif (typeof deviceId != \"undefined\" ) {\n\t\t\tthis.mediaConstraints.audio = { \"deviceId\": deviceId };\n\t\t}\n\t\tthis.setAudioInputSource(streamId, this.mediaConstraints, null, true, deviceId);\n\t}\n\n\tswitchVideoCameraCapture(streamId, deviceId) \n\t{\n\t\t//stop the track because in some android devices need to close the current camera stream\n\t\tvar videoTrack = this.localStream.getVideoTracks()[0];\n\t\tif (videoTrack) {\n\t\t\tvideoTrack.stop();\n\t\t}\n\t\telse {\n\t\t   console.warn(\"There is no video track in local stream\");\n\t\t}\n\t\t\n\t\tthis.publishMode = \"camera\";\n\n\t\tif (typeof deviceId != \"undefined\" ) {\n\t\t\tthis.mediaConstraints.video = { \"deviceId\": deviceId };\n\t\t}\n\t\tthis.setVideoCameraSource(streamId, this.mediaConstraints, null, true, deviceId);\n\t}\n\n\tswitchDesktopCaptureWithCamera(streamId) \n\t{\n\t\tthis.publishMode = \"screen+camera\";\n\n\t\tvar audioConstraint = false;\n\t\tif (typeof this.mediaConstraints.audio != \"undefined\" && this.mediaConstraints.audio != false) {\n\t\t\taudioConstraint = this.mediaConstraints.audio;\n\t\t}\n\t\tthis.getUserMedia(this.mediaConstraints, audioConstraint, streamId);\n\t}\n\t\n\t/**\n\t * This method updates the local stream. It removes existant audio track from the local stream\n\t * and add the audio track in `stream` parameter to the local stream\n\t */\n\tupdateLocalAudioStream(stream, onEndedCallback) \n\t{\n\t\tvar audioTrack = this.localStream.getAudioTracks()[0];\n\t\tthis.localStream.removeTrack(audioTrack);\n\t\taudioTrack.stop();\n\t\tthis.localStream.addTrack(stream.getAudioTracks()[0]);\n\t\tthis.localVideo.srcObject = this.localStream;\n\n\t\tif (onEndedCallback != null) {\n\t\t\tstream.getAudioTracks()[0].onended = function(event) {\n\t\t\t\tonEndedCallback(event);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * This method updates the local stream. It removes existant video track from the local stream\n\t * and add the video track in `stream` parameter to the local stream\n\t */\n\tupdateLocalVideoStream(stream, onEndedCallback, stopDesktop) \n\t{\n\t\tif (stopDesktop && this.desktopStream != null) {\n\t\t\tthis.desktopStream.getVideoTracks()[0].stop();\n\t\t}\n\n\t\tvar videoTrack = this.localStream.getVideoTracks()[0];\n\t\tthis.localStream.removeTrack(videoTrack);\n\t\tvideoTrack.stop();\n\t\tthis.localStream.addTrack(stream.getVideoTracks()[0]);\n\t\tthis.localVideo.srcObject = this.localStream;\n\n\t\tif (onEndedCallback != null) {\n\t\t\tstream.getVideoTracks()[0].onended = function(event) {\n\t\t\t\tonEndedCallback(event);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * This method sets Audio Input Source. \n\t * It calls updateAudioTrack function for the update local audio stream.\n\t */\n\tsetAudioInputSource(streamId, mediaConstraints, onEndedCallback) \n\t{\n\t\tthis.navigatorUserMedia(mediaConstraints,stream => {\n\t\t\tthis.updateAudioTrack(stream, streamId, mediaConstraints, onEndedCallback);\n\t\t}, true);\n\t}\n\t\n\t/**\n\t * This method sets Video Input Source. \n\t * It calls updateVideoTrack function for the update local video stream.\n\t */\n\tsetVideoCameraSource(streamId, mediaConstraints, onEndedCallback, stopDesktop) \n\t{\n\t\tthis.navigatorUserMedia(mediaConstraints, stream => {\n\t\t\tthis.updateVideoTrack(stream, streamId, mediaConstraints, onEndedCallback, stopDesktop);\n\t\t\tthis.updateAudioTrack(stream, streamId, mediaConstraints, onEndedCallback);\n\t\t}, true);\n\t}\n\t\n\tupdateAudioTrack (stream, streamId, onEndedCallback) \n\t{\n\t\tif (this.remotePeerConnection[streamId] != null) {\n\t\t\tvar audioTrackSender = this.remotePeerConnection[streamId].getSenders().find(function(s) {\n\t\t\t\treturn s.track.kind == \"audio\";\n\t\t\t});\n\n\t\t\tif (audioTrackSender) {\n\t\t\t\taudioTrackSender.replaceTrack(stream.getAudioTracks()[0]).then(result => {\n\t\t\t\t\tthis.updateLocalAudioStream(stream, onEndedCallback);\n\t\n\t\t\t\t}).catch(function(error) {\n\t\t\t\t\tconsole.log(error.name);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.error(\"AudioTrackSender is undefined or null\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.updateLocalAudioStream(stream, onEndedCallback);\n\t\t}\n\t}\n\n\tupdateVideoTrack(stream, streamId, mediaConstraints, onEndedCallback, stopDesktop) \n\t{\n\t\tif (this.remotePeerConnection[streamId] != null) {\n\t\t\tvar videoTrackSender = this.remotePeerConnection[streamId].getSenders().find(function(s) {\n\t\t\t\treturn s.track.kind == \"video\";\n\t\t\t});\n\n\t\t\tif (videoTrackSender) {\n\t\t\t\tvideoTrackSender.replaceTrack(stream.getVideoTracks()[0]).then(result => {\n\t\t\t\t\tthis.updateLocalVideoStream(stream, onEndedCallback, stopDesktop);\n\t\n\t\t\t\t}).catch(error => {\n\t\t\t\t\tconsole.log(error.name);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.error(\"VideoTrackSender is undefined or null\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.updateLocalVideoStream(stream, onEndedCallback, stopDesktop);\n\t\t}\n\t}\n\n\tonTrack(event, streamId)\n\t{\n\t\tconsole.log(\"onTrack\");\n\t\tif (this.remoteVideo != null) {\n\t\t\t//this.remoteVideo.srcObject = event.streams[0];\n\t\t\tif (this.remoteVideo.srcObject !== event.streams[0]) {\n\t\t\t\tthis.remoteVideo.srcObject = event.streams[0];\n\t\t\t\tconsole.log('Received remote stream');\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvar dataObj = {\n\t\t\t\t\tstream: event.streams[0],\n\t\t\t\t\ttrack: event.track,\n\t\t\t\t\tstreamId: streamId\n\t\t\t}\n\t\t\tthis.callback(\"newStreamAvailable\", dataObj);\n\t\t}\n\n\t}\n\n\ticeCandidateReceived(event, streamId)\n\t{\n\t\tif (event.candidate) {\n\n\t\t\tvar protocolSupported = false;\n\t\t\t\n\t\t\tif (event.candidate.candidate == \"\") {\n\t\t\t\t//event candidate can be received and its value can be \"\".\n\t\t\t\t//don't compare the protocols\n\t\t\t\tprotocolSupported = true;\n\t\t\t}\n\t\t\telse if (typeof event.candidate.protocol == \"undefined\") {\n\t\t\t\tthis.candidateTypes.forEach(element => {\n\t\t\t\t\tif (event.candidate.candidate.toLowerCase().includes(element)) {\n\t\t\t\t\t\tprotocolSupported = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprotocolSupported = this.candidateTypes.includes(event.candidate.protocol.toLowerCase());\n\t\t\t}\n\t\t\t\n\n\t\t\tif (protocolSupported) {\n\n\t\t\t\tvar jsCmd = {\n\t\t\t\t\t\tcommand : \"takeCandidate\",\n\t\t\t\t\t\tstreamId : streamId,\n\t\t\t\t\t\tlabel : event.candidate.sdpMLineIndex,\n\t\t\t\t\t\tid : event.candidate.sdpMid,\n\t\t\t\t\t\tcandidate : event.candidate.candidate\n\t\t\t\t};\n\n\t\t\t\tif (this.debug) {\n\t\t\t\t\tconsole.log(\"sending ice candiate for stream Id \" + streamId );\n\t\t\t\t\tconsole.log(JSON.stringify(event.candidate));\n\t\t\t\t}\n\t\t\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.log(\"Candidate's protocol(full sdp: \"+ event.candidate.candidate +\") is not supported. Supported protocols: \" + this.candidateTypes);\n\t\t\t\tif (event.candidate.candidate != \"\") { //\n\t\t\t\t\tthis.callbackError(\"protocol_not_supported\", \"Support protocols: \" + this.candidateTypes.toString() + \" candidate: \" + event.candidate.candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tconsole.log(\"No event.candidate in the iceCandidate event\");\n\t\t}\n\t}\n\n\tinitDataChannel(streamId, dataChannel) \n\t{\n\t\tdataChannel.onerror = (error) => {\n\t\t\tconsole.log(\"Data Channel Error:\", error );\n\t\t\tvar obj = {\n\t\t\t\tstreamId: streamId,\n\t\t\t\terror: error\n\t\t\t};\n\t\t\tconsole.log(\"channel status: \", dataChannel.readyState);\n\t\t\tif (dataChannel.readyState != \"closed\") {\n\t\t\t\tthis.callbackError(\"data_channel_error\", obj);\n\t\t\t}\n\t\t};\n\n\t\tdataChannel.onmessage = (event) => {\n\t\t\tvar obj = {\n\t\t\t\tstreamId: streamId,\n\t\t\t\tevent: event,\n\t\t\t};\n\t\t\tthis.callback(\"data_received\", obj);\n\t\t};\n\n\t\tdataChannel.onopen = () => {\n\t\t\tthis.remotePeerConnection[streamId].dataChannel = dataChannel;\n\t\t\tconsole.log(\"Data channel is opened\");\n\t\t\tthis.callback(\"data_channel_opened\", streamId)\n\t\t};\n\n\t\tdataChannel.onclose = () => {\n\t\t\tconsole.log(\"Data channel is closed\");\n\t\t\tthis.callback(\"data_channel_closed\", streamId);\n\t\t};\n\t}\n\n\t// data channel mode can be \"publish\" , \"play\" or \"peer\" based on this it is decided which way data channel is created\n\tinitPeerConnection(streamId, dataChannelMode) \n\t{\n\t\tif (this.remotePeerConnection[streamId] == null)\n\t\t{\n\t\t\tvar closedStreamId = streamId;\n\t\t\tconsole.log(\"stream id in init peer connection: \" + streamId + \" close stream id: \" + closedStreamId);\n\t\t\tthis.remotePeerConnection[streamId] = new RTCPeerConnection(this.peerconnection_config);\n\t\t\tthis.remoteDescriptionSet[streamId] = false;\n\t\t\tthis.iceCandidateList[streamId] = new Array();\n\t\t\tif (!this.playStreamId.includes(streamId))\n\t\t\t{\n\t\t\t\tif(this.localStream != null) {\n\t\t\t\t\tthis.remotePeerConnection[streamId].addStream(this.localStream);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.remotePeerConnection[streamId].onicecandidate = event => {\n\t\t\t\tthis.iceCandidateReceived(event, closedStreamId);\n\t\t\t}\n\t\t\tthis.remotePeerConnection[streamId].ontrack = event => {\n\t\t\t\tthis.onTrack(event, closedStreamId);\n\t\t\t}\n\n\t\t\tif (dataChannelMode == \"publish\") {\n\t\t\t\t//open data channel if it's publish mode peer connection \n\t\t\t\tconst dataChannelOptions = {\n\t\t\t\t\t\tordered: true,\n\t\t\t\t};\n\t\t\t\tif (this.remotePeerConnection[streamId].createDataChannel) {\n\t\t\t\t\tvar dataChannel = this.remotePeerConnection[streamId].createDataChannel(streamId, dataChannelOptions);\n\t\t\t\t\tthis.initDataChannel(streamId, dataChannel);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    console.warn(\"CreateDataChannel is not supported\");\n\t\t\t\t}\n\n\t\t\t} else if(dataChannelMode == \"play\") {\n\t\t\t\t//in play mode, server opens the data channel \n\t\t\t\tthis.remotePeerConnection[streamId].ondatachannel = ev => {\n\t\t\t\t\tthis.initDataChannel(streamId, ev.channel);\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//for peer mode do both for now\n\t\t\t\tconst dataChannelOptions = {\n\t\t\t\t\t\tordered: true,\n\t\t\t\t};\n\n\t\t\t\tif (this.remotePeerConnection[streamId].createDataChannel) \n\t\t\t\t{\n\t\t\t\t\tvar dataChannelPeer = this.remotePeerConnection[streamId].createDataChannel(streamId, dataChannelOptions);\n\t\t\t\t\tthis.initDataChannel(streamId, dataChannelPeer);\n\t\n\t\t\t\t\tthis.remotePeerConnection[streamId].ondatachannel = ev => {\n\t\t\t\t\t\tthis.initDataChannel(streamId, ev.channel);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    console.warn(\"CreateDataChannel is not supported\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.remotePeerConnection[streamId].oniceconnectionstatechange = event => {\n\t\t\t\tvar obj = {state:this.remotePeerConnection[streamId].iceConnectionState, streamId:streamId};\n\t\t\t\tthis.callback(\"ice_connection_state_changed\",obj);\n\n\t\t\t\tif (!this.isPlayMode) {\n\t\t\t\t\tif (this.remotePeerConnection[streamId].iceConnectionState == \"connected\") {\n\n\t\t\t\t\t\tthis.changeBandwidth(this.bandwidth, streamId).then(() => {\n\t\t\t\t\t\t\tconsole.log(\"Bandwidth is changed to \" + this.bandwidth);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(e => console.error(e));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclosePeerConnection(streamId) \n\t{\t\n\t\tif (this.remotePeerConnection[streamId] != null)\n\t\t{\n\t\t\tif (this.remotePeerConnection[streamId].dataChannel != null) {\n\t\t\t\tthis.remotePeerConnection[streamId].dataChannel.close();\n\t\t\t}\n\t\t\tif (this.remotePeerConnection[streamId].signalingState != \"closed\") {\n\t\t\t\tthis.remotePeerConnection[streamId].close();\n\t\t\t\tthis.remotePeerConnection[streamId] = null;\n\t\t\t\tdelete this.remotePeerConnection[streamId];\n\t\t\t\tvar playStreamIndex = this.playStreamId.indexOf(streamId);\n\t\t\t\tif (playStreamIndex != -1)\n\t\t\t\t{\n\t\t\t\t\tthis.playStreamId.splice(playStreamIndex, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.remotePeerConnectionStats[streamId] != null)\n\t\t{\n\t\t\tclearInterval(this.remotePeerConnectionStats[streamId].timerId);\n\t\t\tdelete this.remotePeerConnectionStats[streamId];\n\t\t}\t\t\t\n\t}\n\n\tsignallingState(streamId) \n\t{\n\t\tif (this.remotePeerConnection[streamId] != null) {\n\t\t\treturn this.remotePeerConnection[streamId].signalingState;\n\t\t}\n\t\treturn null;\n\t}\n\n\ticeConnectionState(streamId) \n\t{\n\t\tif (this.remotePeerConnection[streamId] != null) {\n\t\t\treturn this.remotePeerConnection[streamId].iceConnectionState;\n\t\t}\n\t\treturn null;\n\t}\n\n\tgotDescription(configuration, streamId)\n\t{\n\t\tthis.remotePeerConnection[streamId]\n\t\t.setLocalDescription(configuration)\n\t\t.then(responose =>  {\n\t\t\tconsole.debug(\"Set local description successfully for stream Id \" + streamId);\n\n\t\t\tvar jsCmd = {\n\t\t\t\t\tcommand : \"takeConfiguration\",\n\t\t\t\t\tstreamId : streamId,\n\t\t\t\t\ttype : configuration.type,\n\t\t\t\t\tsdp : configuration.sdp\n\n\t\t\t};\n\n\t\t\tif (this.debug) {\n\t\t\t\tconsole.debug(\"local sdp: \");\n\t\t\t\tconsole.debug(configuration.sdp);\n\t\t\t}\n\n\t\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\n\t\t}).catch((error) =>{\n\t\t\tconsole.error(\"Cannot set local description. Error is: \" + error);\n\t\t});\n\t}\n\n\n\tturnOffLocalCamera() \n\t{\n\t\tif (this.remotePeerConnection != null) {\n\n\t\t\tvar track = this.localStream.getVideoTracks()[0];\n\t\t\ttrack.enabled = false;\n\t\t}\n\t\telse {\n\t\t\tthis.callbackError(\"NoActiveConnection\");\n\t\t}\n\t}\n\n\tturnOnLocalCamera() \n\t{\n\t\t//If it started in playOnly mode and wants to turn on the camera\n\t\tif(this.localStream == null){\n\t\t\tthis.navigatorUserMedia(this.mediaConstraints, stream =>{\n\t\t\t\tthis.gotStream(stream);\n\t\t\t}, false);\n\t\t}\n\t\telse if (this.remotePeerConnection != null) {\n\t\t\tvar track = this.localStream.getVideoTracks()[0];\n\t\t\ttrack.enabled = true;\n\t\t}\n\t}\n\n\tmuteLocalMic() \n\t{\n\t\tif (this.remotePeerConnection != null) {\n\t\t\tvar track = this.localStream.getAudioTracks()[0];\n\t\t\ttrack.enabled = false;\n\t\t}\n\t\telse {\n\t\t\tthis.callbackError(\"NoActiveConnection\");\n\t\t}\n\t}\n\n\t/**\n\t * if there is audio it calls callbackError with \"AudioAlreadyActive\" parameter\n\t */\n\tunmuteLocalMic() \n\t{\n\t\tif (this.remotePeerConnection != null) {\n\t\t\tvar track = this.localStream.getAudioTracks()[0];\n\t\t\ttrack.enabled = true;\n\t\t}\n\t\telse {\n\t\t\tthis.callbackError(\"NoActiveConnection\");\n\t\t}\n\t}\n\n\ttakeConfiguration(idOfStream, configuration, typeOfConfiguration)\n\t{\n\t\tvar streamId = idOfStream\n\t\tvar type = typeOfConfiguration;\n\t\tvar conf = configuration;\n\t\tvar isTypeOffer = (type == \"offer\");\n\n\t\tvar dataChannelMode = \"publish\";\n\t\tif(isTypeOffer) {\n\t\t\tdataChannelMode = \"play\";\n\t\t}\n\n\t\tthis.initPeerConnection(streamId, dataChannelMode);\n\n\t\tthis.remotePeerConnection[streamId].setRemoteDescription(new RTCSessionDescription({\n\t\t\tsdp : conf,\n\t\t\ttype : type\n\t\t})).then(response =>  {\n\n\t\t\tif (this.debug) {\n\t\t\t\tconsole.debug(\"set remote description is succesfull with response: \" + response + \" for stream : \"\n\t\t\t\t\t\t+ streamId + \" and type: \" + type);\n\t\t\t\tconsole.debug(conf);\n\t\t\t}\n\n\t\t\tthis.remoteDescriptionSet[streamId] = true;\n\t\t\tvar length = this.iceCandidateList[streamId].length;\n\t\t\tconsole.debug(\"Ice candidate list size to be added: \" + length);\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tthis.addIceCandidate(streamId, this.iceCandidateList[streamId][i]);\n\t\t\t}\n\t\t\tthis.iceCandidateList[streamId] = [];\n\n\t\t\tif (isTypeOffer) {\n\t\t\t\t//SDP constraints may be different in play mode\n\t\t\t\tconsole.log(\"try to create answer for stream id: \" + streamId);\n\n\t\t\t\tthis.remotePeerConnection[streamId].createAnswer(this.sdp_constraints)\n\t\t\t\t.then(configuration =>\n\t\t\t\t\t\t{\n\t\t\t\t\tconsole.log(\"created answer for stream id: \" + streamId);\n\t\t\t\t\tthis.gotDescription(configuration, streamId);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch((error) =>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconsole.error(\"create answer error :\" + error);\n\t\t\t\t\t\t\t\t});\n\t\t\t}\n\n\t\t}).catch((error) => {\n\t\t\tif (this.debug) {\n\t\t\t\tconsole.error(\"set remote description is failed with error: \" + error);\n\t\t\t}\n\t\t\tif(error.toString().indexOf(\"InvalidAccessError\") > -1 || error.toString().indexOf(\"setRemoteDescription\")  > -1){\n\t\t\t\t/**\n\t\t\t\t * This error generally occurs in codec incompatibility.\n\t\t\t\t * AMS for a now supports H.264 codec. This error happens when some browsers try to open it from VP8.\n\t\t\t\t */\n\t\t\t\tthis.callbackError(\"notSetRemoteDescription\");\n\t\t\t}\n\t\t});\n\n\t}\n\n\ttakeCandidate(idOfTheStream, tmpLabel, tmpCandidate) \n\t{\n\t\tvar streamId = idOfTheStream;\n\t\tvar label = tmpLabel;\n\t\tvar candidateSdp = tmpCandidate;\n\n\t\tvar candidate = new RTCIceCandidate({\n\t\t\tsdpMLineIndex : label,\n\t\t\tcandidate : candidateSdp\n\t\t});\n\n\t\tvar dataChannelMode = \"peer\";\n\t\tthis.initPeerConnection(streamId, dataChannelMode);\n\n\t\tif (this.remoteDescriptionSet[streamId] == true) {\n\t\t\tthis.addIceCandidate(streamId, candidate);\n\t\t}\n\t\telse {\n\t\t\tconsole.debug(\"Ice candidate is added to list because remote description is not set yet\");\n\t\t\tthis.iceCandidateList[streamId].push(candidate);\n\t\t}\n\t};\n\n\taddIceCandidate(streamId, candidate) \n\t{\t\n\t\tvar protocolSupported = false;\n\t\tif (candidate.candidate == \"\") {\n\t\t\t//candidate can be received and its value can be \"\".\n\t\t\t//don't compare the protocols\n\t\t\tprotocolSupported = true;\n\t\t}\n\t\telse if (typeof candidate.protocol == \"undefined\") {\n\t\t\tthis.candidateTypes.forEach(element => {\n\t\t\t\tif (candidate.candidate.toLowerCase().includes(element)) {\n\t\t\t\t\tprotocolSupported = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tprotocolSupported = this.candidateTypes.includes(candidate.protocol.toLowerCase());\n\t\t}\t\n\t\t\n\t\tif (protocolSupported)\n\t\t{\n\n\t\t\tthis.remotePeerConnection[streamId].addIceCandidate(candidate)\n\t\t\t.then(response => {\n\t\t\t\tif (this.debug) {\n\t\t\t\t\tconsole.log(\"Candidate is added for stream \" + streamId);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tconsole.error(\"ice candiate cannot be added for stream id: \" + streamId + \" error is: \" + error  );\n\t\t\t\tconsole.error(candidate);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tif (this.debug) {\n\t\t\t\tconsole.log(\"Candidate's protocol(\"+candidate.protocol+\") is not supported.\" +\n\t\t\t\t\t\t\"Candidate: \" + candidate.candidate +\" Supported protocols:\" + this.candidateTypes);\n\t\t\t}\n\t\t}\n\t};\n\n\tstartPublishing(idOfStream) \n\t{\n\t\tvar streamId = idOfStream;\n\n\t\tthis.initPeerConnection(streamId, \"publish\");\n\n\t\tthis.remotePeerConnection[streamId].createOffer(this.sdp_constraints)\n\t\t.then(configuration => {\n\t\t\tthis.gotDescription(configuration, streamId);\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error(\"create offer error for stream id: \" + streamId + \" error: \" + error);\n\t\t});\n\t};\n\n\t/**\n\t * If we have multiple video tracks in coming versions, this method may cause some issues\n\t */\n\tgetVideoSender(streamId) \n\t{\n\t\tvar videoSender = null;\n\t\tif ((adapter.browserDetails.browser === 'chrome' ||\n\t\t\t\t(adapter.browserDetails.browser === 'firefox' ||\n\t\t\t\t\tadapter.browserDetails.browser === 'safari' &&\n\t\t\t\t\t\tadapter.browserDetails.version >= 64)) &&\n\t\t\t\t\t\t'RTCRtpSender' in window &&\n\t\t\t\t\t\t'setParameters' in window.RTCRtpSender.prototype)\n\t\t{\n\t\t\tif (this.remotePeerConnection[streamId] != null) {\n\t\t\t\tconst senders = this.remotePeerConnection[streamId].getSenders();\n\n\t\t\t\tfor (let i = 0; i < senders.length; i++) {\n\t\t\t\t\tif (senders[i].track != null && senders[i].track.kind == \"video\") {\n\t\t\t\t\t\tvideoSender = senders[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn videoSender;\n\t}\n\n\t/**\n\t * bandwidth is in kbps\n\t */\n\tchangeBandwidth(bandwidth, streamId) \n\t{\n\t\tvar errorDefinition = \"\";\n\n\t\tvar videoSender = this.getVideoSender(streamId);\n\n\t\tif (videoSender != null) {\n\t\t\tconst parameters = videoSender.getParameters();\n\n\t\t\tif (!parameters.encodings) {\n\t\t\t\tparameters.encodings = [{}];\n\t\t\t}\n\n\t\t\tif (bandwidth === 'unlimited') {\n\t\t\t\tdelete parameters.encodings[0].maxBitrate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparameters.encodings[0].maxBitrate = bandwidth * 1000;\n\t\t\t}\n\n\t\t\treturn videoSender.setParameters(parameters)\n\t\t}\n\t\telse {\n\t\t\terrorDefinition = \"Video sender not found to change bandwidth. Streaming may not be active\";\n\t\t}\n\n\t\treturn Promise.reject(errorDefinition);\n\t};\n\n\tgetStats(streamId)\n\t{\n\t\tconsole.log(\"peerstatsgetstats = \" + this.remotePeerConnectionStats[streamId]);\n\n\t\tthis.remotePeerConnection[streamId].getStats(null).then(stats =>\n\t\t{\n\t\t\tvar bytesReceived = -1;\n\t\t\tvar videoPacketsLost = -1;\n\t\t\tvar audioPacketsLost = -1;\n\t\t\tvar fractionLost = -1;\n\t\t\tvar currentTime = -1;\n\t\t\tvar bytesSent = -1;\n\t\t\tvar audioLevel = -1;\n\t\t\tvar qlr = \"\";\n\t\t\tvar framesEncoded = -1;\n\t\t\tvar width = -1;\n\t\t\tvar height = -1;\n\t\t\tvar fps = -1;\n\t\t\tvar frameWidth = -1;\n\t\t\tvar frameHeight = -1;\n\t\t\tvar videoRoundTripTime = -1;\n\t\t\tvar videoJitter = -1;\n\n\t\t\tvar audioRoundTripTime = -1;\n\t\t\tvar audioJitter = -1;\n\t\t\t\n\t\t\tvar framesDecoded = -1;\n\t\t\tvar framesDropped = -1;\n\t\t\tvar framesReceived = -1;\n\t\t\t\n\t\t\tvar audioJitterAverageDelay = -1;\n\t        var videoJitterAverageDelay = -1;\n\n\n\t\t\tstats.forEach(value => {\n\n\t\t\t\t//console.log(value);\n\n\t\t\t\tif (value.type == \"inbound-rtp\" && typeof value.kind != \"undefined\")\n\t\t\t\t{\n\t\t\t\t\tbytesReceived += value.bytesReceived;\n\t\t\t\t\tif (value.kind == \"audio\") {\n\t\t\t\t\t\taudioPacketsLost = value.packetsLost;\n\t\t\t\t\t}\n\t\t\t\t\telse if (value.kind == \"video\") {\n\t\t\t\t\t\tvideoPacketsLost = value.packetsLost;\n\t\t\t\t\t}\n\n\t\t\t\t\tfractionLost += value.fractionLost;\n\t\t\t\t\tcurrentTime = value.timestamp;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (value.type == \"outbound-rtp\")\n\t\t\t\t{//TODO: SPLIT AUDIO AND VIDEO BITRATES\n\t\t\t\t\tbytesSent += value.bytesSent\n\t\t\t\t\tcurrentTime = value.timestamp\n\t\t\t\t\tqlr = value.qualityLimitationReason;\n\t\t\t\t\tif(value.framesEncoded != null) { //audio tracks are undefined here\n\t\t\t\t\t\tframesEncoded += value.framesEncoded;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (value.type == \"track\" && typeof value.kind != \"undefined\" && value.kind == \"audio\") {\n\t\t\t\t\tif (typeof value.audioLevel != \"undefined\") {\n\t\t\t\t\t\taudioLevel = value.audioLevel;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (typeof value.jitterBufferDelay != \"undefined\" && typeof value.jitterBufferEmittedCount != \"undefined\") {\n\t\t\t\t\t\taudioJitterAverageDelay = value.jitterBufferDelay/value.jitterBufferEmittedCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (value.type == \"track\" && typeof value.kind != \"undefined\" && value.kind == \"video\") \n\t\t\t\t{\n\t\t\t\t\tif (typeof value.frameWidth != \"undefined\") {\n\t\t\t\t\t\tframeWidth = value.frameWidth;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof value.frameHeight != \"undefined\") {\n\t\t\t\t\t\tframeHeight = value.frameHeight;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (typeof value.framesDecoded != \"undefined\") {\n\t\t\t\t\t\tframesDecoded = value.framesDecoded ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (typeof value.framesDropped != \"undefined\") {\n\t\t\t\t\t\tframesDropped = value.framesDropped;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (typeof value.framesReceived != \"undefined\") {\n\t\t\t\t\t\tframesReceived = value.framesReceived;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (typeof value.jitterBufferDelay != \"undefined\" && typeof value.jitterBufferEmittedCount != \"undefined\") {\n\t\t\t\t\t\tvideoJitterAverageDelay = value.jitterBufferDelay/value.jitterBufferEmittedCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (value.type == \"remote-inbound-rtp\" && typeof value.kind != \"undefined\") {\n\n\t\t\t\t\tif (typeof value.packetsLost != \"undefined\") {\n\t\t\t\t\t\tif (value.kind == \"video\") {\n\t\t\t\t\t\t\t//this is the packetsLost for publishing\n\t\t\t\t\t\t\tvideoPacketsLost = value.packetsLost;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (value.kind == \"audio\") {\n\t\t\t\t\t\t\t//this is the packetsLost for publishing\n\t\t\t\t\t\t\taudioPacketsLost = value.packetsLost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof value.roundTripTime != \"undefined\") {\n\t\t\t\t\t\tif (value.kind == \"video\") {\n\t\t\t\t\t\t\tvideoRoundTripTime = value.roundTripTime;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (value.kind == \"audio\") {\n\t\t\t\t\t\t\taudioRoundTripTime = value.roundTripTime;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof value.jitter != \"undefined\") {\n\t\t\t\t\t\tif (value.kind == \"video\") {\n\t\t\t\t\t\t\tvideoJitter = value.jitter;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (value.kind == \"audio\") {\n\t\t\t\t\t\t\taudioJitter = value.jitter;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (value.type == \"media-source\")\n\t\t\t\t{\n\t\t\t\t\tif(value.kind == \"video\") { //returns video source dimensions, not necessarily dimensions being encoded by browser\n\t\t\t\t\t\twidth = value.width;\n\t\t\t\t\t\theight = value.height;\n\t\t\t\t\t\tfps = value.framesPerSecond;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.remotePeerConnectionStats[streamId].totalBytesReceived = bytesReceived;\n\t\t\tthis.remotePeerConnectionStats[streamId].videoPacketsLost = videoPacketsLost;\n\t\t\tthis.remotePeerConnectionStats[streamId].audioPacketsLost = audioPacketsLost;\n\t\t\tthis.remotePeerConnectionStats[streamId].fractionLost = fractionLost;\n\t\t\tthis.remotePeerConnectionStats[streamId].currentTime = currentTime;\n\t\t\tthis.remotePeerConnectionStats[streamId].totalBytesSent = bytesSent;\n\t\t\tthis.remotePeerConnectionStats[streamId].audioLevel = audioLevel;\n\t\t\tthis.remotePeerConnectionStats[streamId].qualityLimitationReason = qlr;\n\t\t\tthis.remotePeerConnectionStats[streamId].totalFramesEncoded = framesEncoded;\n\t\t\tthis.remotePeerConnectionStats[streamId].resWidth = width;\n\t\t\tthis.remotePeerConnectionStats[streamId].resHeight = height;\n\t\t\tthis.remotePeerConnectionStats[streamId].srcFps = fps;\n\t\t\tthis.remotePeerConnectionStats[streamId].frameWidth = frameWidth;\n\t\t\tthis.remotePeerConnectionStats[streamId].frameHeight = frameHeight;\n\t\t\tthis.remotePeerConnectionStats[streamId].videoRoundTripTime = videoRoundTripTime;\n\t\t\tthis.remotePeerConnectionStats[streamId].videoJitter = videoJitter;\n\t\t\tthis.remotePeerConnectionStats[streamId].audioRoundTripTime = audioRoundTripTime;\n\t\t\tthis.remotePeerConnectionStats[streamId].audioJitter = audioJitter;\n\t\t\tthis.remotePeerConnectionStats[streamId].framesDecoded = framesDecoded;\n\t\t\tthis.remotePeerConnectionStats[streamId].framesDropped = framesDropped;\n\t\t\tthis.remotePeerConnectionStats[streamId].framesReceived = framesReceived;\n\t\t\t\n\t\t\tthis.remotePeerConnectionStats[streamId].videoJitterAverageDelay = videoJitterAverageDelay;\n\t\t\tthis.remotePeerConnectionStats[streamId].audioJitterAverageDelay = audioJitterAverageDelay;\n\n\n\t\t\tthis.callback(\"updated_stats\", this.remotePeerConnectionStats[streamId]);\n\n\t\t});\n\t}\n\tdisableStats(streamId) \n\t{\n\t\tclearInterval(this.remotePeerConnectionStats[streamId].timerId);\n\t}\n\n\tenableStats(streamId) \n\t{\n\t\tif (this.remotePeerConnectionStats[streamId] == null) {\n\t\t\tthis.remotePeerConnectionStats[streamId] = new PeerStats(streamId);\n\t\t\tthis.remotePeerConnectionStats[streamId].timerId = setInterval(() =>\n\t\t\t{\n\t\t\t\tthis.getStats(streamId);\n\n\t\t\t}, 5000);\n\t\t}\n\t}\n\n\t/**\n\t * After calling this function, create new WebRTCAdaptor instance, don't use the the same objectone\n\t * Because all streams are closed on server side as well when websocket connection is closed.\n\t */\n\tcloseWebSocket() \n\t{\n\t\tfor (var key in this.remotePeerConnection) {\n\t\t\tthis.remotePeerConnection[key].close();\n\t\t}\n\t\t//free the remote peer connection by initializing again\n\t\tthis.remotePeerConnection = new Array();\n\t\tthis.webSocketAdaptor.close();\n\t}\n\n\tpeerMessage(streamId, definition, data) \n\t{\n\t\tvar jsCmd = {\n\t\t\t\tcommand : \"peerMessageCommand\",\n\t\t\t\tstreamId : streamId,\n\t\t\t\tdefinition : definition,\n\t\t\t\tdata: data,\n\t\t};\n\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\t\n\tforceStreamQuality(streamId, resolution) \n\t{\n\t\tvar jsCmd = {\n\t\t\t\tcommand : \"forceStreamQuality\",\n\t\t\t\tstreamId : streamId,\n\t\t\t\tstreamHeight : resolution\n\t\t};\n\t\tthis.webSocketAdaptor.send(JSON.stringify(jsCmd));\n\t}\n\n\tsendData(streamId, message) \n\t{\n\t\tvar dataChannel = this.remotePeerConnection[streamId].dataChannel;\n\t\tdataChannel.send(message);\n\t}\n}","/Users/interone/Downloads/webapps/ant-media-demo/src/js/peer_stats.js",["143","144","145","146"],"export class PeerStats {\n\n    constructor(streamId) {\n        this.streamId = streamId;\n        this.totalBytesReceivedCount = 0;\n        this.totalBytesSent = 0;\n        this.videoPacketsLost = 0;\n        this.fractionLost = 0;\n        this.startTime = 0;\n        this.lastFramesEncoded = 0;\n\t\tthis.totalFramesEncodedCount = 0;\n        this.lastBytesReceived = 0;\n        this.lastBytesSent = 0;\n        this.currentTimestamp = 0;\n        this.lastTime = 0;\n        this.timerId = 0;\n        this.firstByteSentCount = 0;\n        this.firstBytesReceivedCount = 0;\n        this.audioLevel = -1;\n        this.qualityLimitationReason = \"\";\n        //res width and res height are video source resolutions\n        this.resWidth = 0;\n        this.resHeight = 0;\n        this.srcFps = 0;\n        //frameWidth and frameHeight are the resolutions of the sent video\n        this.frameWidth = 0;\n        this.frameHeight = 0;\n\n        this.videoRoundTripTime = 0;\n        this.videoJitter = 0;\n\n        this.audioRoundTripTime = 0;\n        this.audioJitter = 0;\n\n        this.audioPacketsLost = 0;\n\n        this.framesReceived = 0;\n        this.framesDropped = 0;\n        this.framesDecoded = 0;\n\n        this.audioJitterAverageDelay = 0;\n        this.videoJitterAverageDelay = 0;\n    }\n\n    //kbits/sec\n    get averageOutgoingBitrate() {\n        return Math.floor(8 * (this.totalBytesSentCount - this.firstByteSentCount) / (this.currentTimestamp - this.startTime));\n    }\n\n    //frames per second\n    get currentFPS() {\n        return (((this.totalFramesEncodedCount - this.lastFramesEncoded) / (this.currentTimestamp - this.lastTime))*1000).toFixed(1);\n    }\n    //kbits/sec\n    get averageIncomingBitrate() {\n        return Math.floor(8 * (this.totalBytesReceivedCount - this.firstBytesReceivedCount) / (this.currentTimestamp - this.startTime));\n    }\n\n    //kbits/sec\n    get currentOutgoingBitrate() {\n        return Math.floor(8 * (this.totalBytesSentCount - this.lastBytesSent) / (this.currentTimestamp - this.lastTime));\n    }\n\n    //kbits/sec\n    get currentIncomingBitrate() {\n        return Math.floor(8 * (this.totalBytesReceivedCount - this.lastBytesReceived) / (this.currentTimestamp - this.lastTime));\n    }\n\n    set currentTime(timestamp) {\n        this.lastTime = this.currentTimestamp;\n        this.currentTimestamp = timestamp;\n        if (this.startTime == 0) {\n            this.startTime = timestamp-1; // do not have zero division error\n        }\n    }\n\n    set totalBytesReceived(bytesReceived) {\n        this.lastBytesReceived = this.totalBytesReceivedCount;\n        this.totalBytesReceivedCount = bytesReceived;\n        if (this.firstBytesReceivedCount == 0) {\n            this.firstBytesReceivedCount = bytesReceived;\n        }\n    }\n\n    set totalBytesSent(bytesSent) {\n        this.lastBytesSent = this.totalBytesSentCount;\n        this.totalBytesSentCount = bytesSent;\n        if (this.firstByteSentCount == 0) {\n            this.firstByteSentCount = bytesSent;\n        }\n    }\n    set totalFramesEncoded(framesEncoded) {\n        this.lastFramesEncoded = this.totalFramesEncodedCount;\n        this.totalFramesEncodedCount = framesEncoded;\n        if (this.lastFramesEncoded == 0) {\n            this.lastFramesEncoded = framesEncoded;\n        }\n    }\n\n}","/Users/interone/Downloads/webapps/ant-media-demo/src/js/websocket_adaptor.js",["147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164"],"export class WebSocketAdaptor {\n    constructor(initialValues){\n        \n        for(var key in initialValues) {\n\t\t\tif(initialValues.hasOwnProperty(key)) {\n\t\t\t\tthis[key] = initialValues[key];\n\t\t\t}\n        }\n        this.wsConn = new WebSocket(this.websocket_url);\n\n        this.isWebSocketTriggered = true;\n\n        this.connected = false;\n\n        this.pingTimerId = -1;\n\n        this.wsConn.onopen = () => {\n            if (true) {\n                console.log(\"websocket connected\");\n            }\n    \n            this.pingTimerId = setInterval(() => {\n                this.sendPing();\n            }, 3000);\n    \n            this.connected = true;\n            this.callback(\"initialized\");\n        }\n\n        this.wsConn.onmessage = (event) => {\n            var obj = JSON.parse(event.data);\n\n            if (obj.command == \"start\")\n            {\n                //this command is received first, when publishing so playmode is false\n\n                if (this.debug) {\n                    console.debug(\"received start command\");\n                }\n\n                this.webrtcadaptor.startPublishing(obj.streamId);\n            }\n            else if (obj.command == \"takeCandidate\") {\n\n                if (this.debug) {\n                    console.debug(\"received ice candidate for stream id \" + obj.streamId);\n                    console.debug(obj.candidate);\n                }\n\n                this.webrtcadaptor.takeCandidate(obj.streamId, obj.label, obj.candidate);\n\n            } else if (obj.command == \"takeConfiguration\") {\n\n                if (this.debug) {\n                    console.log(\"received remote description type for stream id: \" + obj.streamId + \" type: \" + obj.type );\n                }\n                this.webrtcadaptor.takeConfiguration(obj.streamId, obj.sdp, obj.type);\n\n            }\n            else if (obj.command == \"stop\") {\n                console.debug(\"Stop command received\");\n                this.webrtcadaptor.closePeerConnection(obj.streamId);\n            }\n            else if (obj.command == \"error\") {\n                this.callbackError(obj.definition);\n            }\n            else if (obj.command == \"notification\") {\n                this.callback(obj.definition, obj);\n                if (obj.definition == \"play_finished\" || obj.definition == \"publish_finished\") {\n                    this.webrtcadaptor.closePeerConnection(obj.streamId);\n                }\n            }\n            else if (obj.command == \"streamInformation\") {\n                this.callback(obj.command, obj);\n            }\n            else if (obj.command == \"roomInformation\") {\n                this.callback(obj.command, obj);\n            }\n            else if (obj.command == \"pong\") {\n                this.callback(obj.command);\n            }\n            else if (obj.command == \"trackList\") {\n                this.callback(obj.command, obj);\n            }\n            else if (obj.command == \"connectWithNewId\") {\n                this.multiPeerStreamId = obj.streamId;\n                this.join(obj.streamId);\n            }\n            else if (obj.command == \"peerMessageCommand\") {\n                this.callback(obj.command, obj);\n            }\n        }\n\n        this.wsConn.onerror = (error) => {\n            console.log(\" error occured: \" + JSON.stringify(error));\n            this.clearPingTimer();\n            this.callbackError(error)\n        }\n\n        this.wsConn.onclose = (event) => {\n            this.connected = false;\n            console.log(\"connection closed.\");\n            this.clearPingTimer();\n            this.callback(\"closed\", event);\n        }\n    }\n\n    clearPingTimer(){\n        if (this.pingTimerId != -1) {\n            if (this.debug) {\n                console.debug(\"Clearing ping message timer\");\n            }\n            clearInterval(this.pingTimerId);\n            this.pingTimerId = -1;\n        }\n    }\n\n    sendPing() {\n        var jsCmd = {\n                command : \"ping\"\n        };\n        this.wsConn.send(JSON.stringify(jsCmd));\n    }\n\n    close() {\n        this.wsConn.close();\n    }\n\n    send(text){\n\n        if (this.wsConn.readyState == 0 || this.wsConn.readyState == 2 || this.wsConn.readyState == 3) {\n            this.callbackError(\"WebSocketNotConnected\");\n            return;\n        }\n        this.wsConn.send(text);\n        console.log(\"sent message:\" +text);\n    }\n\n    isConnected(){\n        return this.connected;\n    }\n}",["165","166"],{"ruleId":"167","replacedBy":"168"},{"ruleId":"169","replacedBy":"170"},{"ruleId":"171","severity":1,"message":"172","line":2,"column":8,"nodeType":"173","messageId":"174","endLine":2,"endColumn":12},{"ruleId":"175","severity":1,"message":"176","line":9,"column":3,"nodeType":"177","messageId":"178","endLine":11,"endColumn":4},{"ruleId":"179","severity":1,"message":"180","line":33,"column":11,"nodeType":"181","messageId":"182","endLine":33,"endColumn":25},{"ruleId":"183","severity":1,"message":"184","line":33,"column":19,"nodeType":"181","messageId":"185","endLine":33,"endColumn":21},{"ruleId":"183","severity":1,"message":"184","line":97,"column":23,"nodeType":"181","messageId":"185","endLine":97,"endColumn":25},{"ruleId":"183","severity":1,"message":"184","line":101,"column":28,"nodeType":"181","messageId":"185","endLine":101,"endColumn":30},{"ruleId":"183","severity":1,"message":"186","line":138,"column":48,"nodeType":"181","messageId":"185","endLine":138,"endColumn":50},{"ruleId":"183","severity":1,"message":"186","line":138,"column":72,"nodeType":"181","messageId":"185","endLine":138,"endColumn":74},{"ruleId":"183","severity":1,"message":"184","line":159,"column":42,"nodeType":"181","messageId":"185","endLine":159,"endColumn":44},{"ruleId":"183","severity":1,"message":"184","line":159,"column":66,"nodeType":"181","messageId":"185","endLine":159,"endColumn":68},{"ruleId":"183","severity":1,"message":"186","line":172,"column":42,"nodeType":"181","messageId":"185","endLine":172,"endColumn":44},{"ruleId":"183","severity":1,"message":"186","line":174,"column":50,"nodeType":"181","messageId":"185","endLine":174,"endColumn":52},{"ruleId":"183","severity":1,"message":"186","line":174,"column":74,"nodeType":"181","messageId":"185","endLine":174,"endColumn":76},{"ruleId":"183","severity":1,"message":"184","line":233,"column":22,"nodeType":"181","messageId":"185","endLine":233,"endColumn":24},{"ruleId":"183","severity":1,"message":"184","line":241,"column":29,"nodeType":"181","messageId":"185","endLine":241,"endColumn":31},{"ruleId":"183","severity":1,"message":"184","line":254,"column":29,"nodeType":"181","messageId":"185","endLine":254,"endColumn":31},{"ruleId":"183","severity":1,"message":"184","line":261,"column":27,"nodeType":"181","messageId":"185","endLine":261,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":267,"column":27,"nodeType":"181","messageId":"185","endLine":267,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":272,"column":27,"nodeType":"181","messageId":"185","endLine":272,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":278,"column":27,"nodeType":"181","messageId":"185","endLine":278,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":282,"column":27,"nodeType":"181","messageId":"185","endLine":282,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":285,"column":27,"nodeType":"181","messageId":"185","endLine":285,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":288,"column":27,"nodeType":"181","messageId":"185","endLine":288,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":372,"column":27,"nodeType":"181","messageId":"185","endLine":372,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":376,"column":27,"nodeType":"181","messageId":"185","endLine":376,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":380,"column":33,"nodeType":"181","messageId":"185","endLine":380,"endColumn":35},{"ruleId":"183","severity":1,"message":"184","line":383,"column":38,"nodeType":"181","messageId":"185","endLine":383,"endColumn":40},{"ruleId":"187","severity":1,"message":"188","line":422,"column":17,"nodeType":"173","messageId":"189","endLine":422,"endColumn":29},{"ruleId":"183","severity":1,"message":"186","line":423,"column":48,"nodeType":"181","messageId":"185","endLine":423,"endColumn":50},{"ruleId":"183","severity":1,"message":"186","line":426,"column":56,"nodeType":"181","messageId":"185","endLine":426,"endColumn":58},{"ruleId":"183","severity":1,"message":"186","line":426,"column":98,"nodeType":"181","messageId":"185","endLine":426,"endColumn":100},{"ruleId":"183","severity":1,"message":"186","line":429,"column":59,"nodeType":"181","messageId":"185","endLine":429,"endColumn":61},{"ruleId":"183","severity":1,"message":"186","line":429,"column":113,"nodeType":"181","messageId":"185","endLine":429,"endColumn":115},{"ruleId":"183","severity":1,"message":"186","line":432,"column":55,"nodeType":"181","messageId":"185","endLine":432,"endColumn":57},{"ruleId":"183","severity":1,"message":"186","line":432,"column":103,"nodeType":"181","messageId":"185","endLine":432,"endColumn":105},{"ruleId":"183","severity":1,"message":"186","line":435,"column":49,"nodeType":"181","messageId":"185","endLine":435,"endColumn":51},{"ruleId":"183","severity":1,"message":"186","line":438,"column":67,"nodeType":"181","messageId":"185","endLine":438,"endColumn":69},{"ruleId":"183","severity":1,"message":"186","line":442,"column":61,"nodeType":"181","messageId":"185","endLine":442,"endColumn":63},{"ruleId":"190","severity":1,"message":"191","line":14,"column":31,"nodeType":"192","messageId":"193","endLine":14,"endColumn":42},{"ruleId":"190","severity":1,"message":"191","line":15,"column":36,"nodeType":"192","messageId":"193","endLine":15,"endColumn":47},{"ruleId":"190","severity":1,"message":"191","line":16,"column":31,"nodeType":"192","messageId":"193","endLine":16,"endColumn":42},{"ruleId":"190","severity":1,"message":"191","line":17,"column":27,"nodeType":"192","messageId":"193","endLine":17,"endColumn":38},{"ruleId":"190","severity":1,"message":"191","line":21,"column":23,"nodeType":"192","messageId":"193","endLine":21,"endColumn":34},{"ruleId":"183","severity":1,"message":"184","line":74,"column":34,"nodeType":"181","messageId":"185","endLine":74,"endColumn":36},{"ruleId":"183","severity":1,"message":"184","line":77,"column":39,"nodeType":"181","messageId":"185","endLine":77,"endColumn":41},{"ruleId":"183","severity":1,"message":"184","line":80,"column":39,"nodeType":"181","messageId":"185","endLine":80,"endColumn":41},{"ruleId":"183","severity":1,"message":"184","line":90,"column":71,"nodeType":"181","messageId":"185","endLine":90,"endColumn":73},{"ruleId":"183","severity":1,"message":"186","line":102,"column":89,"nodeType":"181","messageId":"185","endLine":102,"endColumn":91},{"ruleId":"183","severity":1,"message":"184","line":116,"column":77,"nodeType":"181","messageId":"185","endLine":116,"endColumn":79},{"ruleId":"183","severity":1,"message":"184","line":168,"column":30,"nodeType":"181","messageId":"185","endLine":168,"endColumn":32},{"ruleId":"190","severity":1,"message":"191","line":181,"column":22,"nodeType":"192","messageId":"193","endLine":181,"endColumn":33},{"ruleId":"183","severity":1,"message":"184","line":184,"column":21,"nodeType":"181","messageId":"185","endLine":184,"endColumn":23},{"ruleId":"183","severity":1,"message":"184","line":184,"column":52,"nodeType":"181","messageId":"185","endLine":184,"endColumn":54},{"ruleId":"183","severity":1,"message":"184","line":186,"column":20,"nodeType":"181","messageId":"185","endLine":186,"endColumn":22},{"ruleId":"183","severity":1,"message":"184","line":192,"column":18,"nodeType":"181","messageId":"185","endLine":192,"endColumn":20},{"ruleId":"183","severity":1,"message":"184","line":206,"column":49,"nodeType":"181","messageId":"185","endLine":206,"endColumn":51},{"ruleId":"183","severity":1,"message":"186","line":211,"column":23,"nodeType":"181","messageId":"185","endLine":211,"endColumn":25},{"ruleId":"183","severity":1,"message":"186","line":211,"column":57,"nodeType":"181","messageId":"185","endLine":211,"endColumn":59},{"ruleId":"183","severity":1,"message":"184","line":221,"column":25,"nodeType":"181","messageId":"185","endLine":221,"endColumn":27},{"ruleId":"183","severity":1,"message":"184","line":231,"column":30,"nodeType":"181","messageId":"185","endLine":231,"endColumn":32},{"ruleId":"183","severity":1,"message":"186","line":243,"column":25,"nodeType":"181","messageId":"185","endLine":243,"endColumn":27},{"ruleId":"183","severity":1,"message":"186","line":243,"column":53,"nodeType":"181","messageId":"185","endLine":243,"endColumn":55},{"ruleId":"183","severity":1,"message":"184","line":260,"column":19,"nodeType":"181","messageId":"185","endLine":260,"endColumn":21},{"ruleId":"183","severity":1,"message":"184","line":262,"column":19,"nodeType":"181","messageId":"185","endLine":262,"endColumn":21},{"ruleId":"183","severity":1,"message":"184","line":279,"column":23,"nodeType":"181","messageId":"185","endLine":279,"endColumn":25},{"ruleId":"183","severity":1,"message":"184","line":279,"column":62,"nodeType":"181","messageId":"185","endLine":279,"endColumn":64},{"ruleId":"183","severity":1,"message":"186","line":322,"column":78,"nodeType":"181","messageId":"185","endLine":322,"endColumn":80},{"ruleId":"183","severity":1,"message":"184","line":532,"column":76,"nodeType":"181","messageId":"185","endLine":532,"endColumn":78},{"ruleId":"183","severity":1,"message":"186","line":541,"column":88,"nodeType":"181","messageId":"185","endLine":541,"endColumn":90},{"ruleId":"183","severity":1,"message":"186","line":626,"column":88,"nodeType":"181","messageId":"185","endLine":626,"endColumn":90},{"ruleId":"183","severity":1,"message":"184","line":701,"column":25,"nodeType":"181","messageId":"185","endLine":701,"endColumn":27},{"ruleId":"183","severity":1,"message":"184","line":725,"column":25,"nodeType":"181","messageId":"185","endLine":725,"endColumn":27},{"ruleId":"183","severity":1,"message":"184","line":772,"column":34,"nodeType":"181","messageId":"185","endLine":772,"endColumn":36},{"ruleId":"183","severity":1,"message":"186","line":807,"column":35,"nodeType":"181","messageId":"185","endLine":807,"endColumn":37},{"ruleId":"183","severity":1,"message":"186","line":826,"column":31,"nodeType":"181","messageId":"185","endLine":826,"endColumn":33},{"ruleId":"190","severity":1,"message":"191","line":860,"column":38,"nodeType":"192","messageId":"193","endLine":860,"endColumn":49},{"ruleId":"183","severity":1,"message":"184","line":874,"column":24,"nodeType":"181","messageId":"185","endLine":874,"endColumn":26},{"ruleId":"183","severity":1,"message":"184","line":887,"column":30,"nodeType":"181","messageId":"185","endLine":887,"endColumn":32},{"ruleId":"183","severity":1,"message":"184","line":918,"column":65,"nodeType":"181","messageId":"185","endLine":918,"endColumn":67},{"ruleId":"183","severity":1,"message":"186","line":938,"column":59,"nodeType":"181","messageId":"185","endLine":938,"endColumn":61},{"ruleId":"183","severity":1,"message":"186","line":943,"column":25,"nodeType":"181","messageId":"185","endLine":943,"endColumn":27},{"ruleId":"183","severity":1,"message":"184","line":1057,"column":27,"nodeType":"181","messageId":"185","endLine":1057,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":1130,"column":43,"nodeType":"181","messageId":"185","endLine":1130,"endColumn":45},{"ruleId":"183","severity":1,"message":"184","line":1142,"column":27,"nodeType":"181","messageId":"185","endLine":1142,"endColumn":29},{"ruleId":"194","severity":1,"message":"195","line":1202,"column":51,"nodeType":"196","messageId":"197","endLine":1202,"endColumn":53},{"ruleId":"194","severity":1,"message":"195","line":1203,"column":50,"nodeType":"196","messageId":"197","endLine":1203,"endColumn":52},{"ruleId":"183","severity":1,"message":"184","line":1212,"column":60,"nodeType":"181","messageId":"185","endLine":1212,"endColumn":62},{"ruleId":"183","severity":1,"message":"184","line":1293,"column":20,"nodeType":"181","messageId":"185","endLine":1293,"endColumn":22},{"ruleId":"183","severity":1,"message":"184","line":1296,"column":21,"nodeType":"181","messageId":"185","endLine":1296,"endColumn":23},{"ruleId":"183","severity":1,"message":"184","line":1299,"column":26,"nodeType":"181","messageId":"185","endLine":1299,"endColumn":28},{"ruleId":"183","severity":1,"message":"184","line":1308,"column":25,"nodeType":"181","messageId":"185","endLine":1308,"endColumn":27},{"ruleId":"183","severity":1,"message":"184","line":1317,"column":25,"nodeType":"181","messageId":"185","endLine":1317,"endColumn":27},{"ruleId":"183","severity":1,"message":"184","line":1317,"column":86,"nodeType":"181","messageId":"185","endLine":1317,"endColumn":88},{"ruleId":"183","severity":1,"message":"184","line":1326,"column":25,"nodeType":"181","messageId":"185","endLine":1326,"endColumn":27},{"ruleId":"183","severity":1,"message":"184","line":1326,"column":86,"nodeType":"181","messageId":"185","endLine":1326,"endColumn":88},{"ruleId":"183","severity":1,"message":"184","line":1351,"column":25,"nodeType":"181","messageId":"185","endLine":1351,"endColumn":27},{"ruleId":"183","severity":1,"message":"184","line":1354,"column":22,"nodeType":"181","messageId":"185","endLine":1354,"endColumn":24},{"ruleId":"183","severity":1,"message":"184","line":1358,"column":27,"nodeType":"181","messageId":"185","endLine":1358,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":1365,"column":22,"nodeType":"181","messageId":"185","endLine":1365,"endColumn":24},{"ruleId":"183","severity":1,"message":"184","line":1368,"column":27,"nodeType":"181","messageId":"185","endLine":1368,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":1374,"column":22,"nodeType":"181","messageId":"185","endLine":1374,"endColumn":24},{"ruleId":"183","severity":1,"message":"184","line":1377,"column":27,"nodeType":"181","messageId":"185","endLine":1377,"endColumn":29},{"ruleId":"183","severity":1,"message":"184","line":1382,"column":25,"nodeType":"181","messageId":"185","endLine":1382,"endColumn":27},{"ruleId":"183","severity":1,"message":"184","line":1384,"column":20,"nodeType":"181","messageId":"185","endLine":1384,"endColumn":22},{"ruleId":"190","severity":1,"message":"191","line":1449,"column":31,"nodeType":"192","messageId":"193","endLine":1449,"endColumn":42},{"ruleId":"183","severity":1,"message":"184","line":72,"column":28,"nodeType":"181","messageId":"185","endLine":72,"endColumn":30},{"ruleId":"183","severity":1,"message":"184","line":80,"column":42,"nodeType":"181","messageId":"185","endLine":80,"endColumn":44},{"ruleId":"183","severity":1,"message":"184","line":88,"column":37,"nodeType":"181","messageId":"185","endLine":88,"endColumn":39},{"ruleId":"183","severity":1,"message":"184","line":95,"column":36,"nodeType":"181","messageId":"185","endLine":95,"endColumn":38},{"ruleId":"183","severity":1,"message":"184","line":33,"column":29,"nodeType":"181","messageId":"185","endLine":33,"endColumn":31},{"ruleId":"183","severity":1,"message":"184","line":43,"column":34,"nodeType":"181","messageId":"185","endLine":43,"endColumn":36},{"ruleId":"183","severity":1,"message":"184","line":52,"column":36,"nodeType":"181","messageId":"185","endLine":52,"endColumn":38},{"ruleId":"183","severity":1,"message":"184","line":60,"column":34,"nodeType":"181","messageId":"185","endLine":60,"endColumn":36},{"ruleId":"183","severity":1,"message":"184","line":64,"column":34,"nodeType":"181","messageId":"185","endLine":64,"endColumn":36},{"ruleId":"183","severity":1,"message":"184","line":67,"column":34,"nodeType":"181","messageId":"185","endLine":67,"endColumn":36},{"ruleId":"183","severity":1,"message":"184","line":69,"column":36,"nodeType":"181","messageId":"185","endLine":69,"endColumn":38},{"ruleId":"183","severity":1,"message":"184","line":69,"column":73,"nodeType":"181","messageId":"185","endLine":69,"endColumn":75},{"ruleId":"183","severity":1,"message":"184","line":73,"column":34,"nodeType":"181","messageId":"185","endLine":73,"endColumn":36},{"ruleId":"183","severity":1,"message":"184","line":76,"column":34,"nodeType":"181","messageId":"185","endLine":76,"endColumn":36},{"ruleId":"183","severity":1,"message":"184","line":79,"column":34,"nodeType":"181","messageId":"185","endLine":79,"endColumn":36},{"ruleId":"183","severity":1,"message":"184","line":82,"column":34,"nodeType":"181","messageId":"185","endLine":82,"endColumn":36},{"ruleId":"183","severity":1,"message":"184","line":85,"column":34,"nodeType":"181","messageId":"185","endLine":85,"endColumn":36},{"ruleId":"183","severity":1,"message":"184","line":89,"column":34,"nodeType":"181","messageId":"185","endLine":89,"endColumn":36},{"ruleId":"183","severity":1,"message":"186","line":109,"column":30,"nodeType":"181","messageId":"185","endLine":109,"endColumn":32},{"ruleId":"183","severity":1,"message":"184","line":131,"column":36,"nodeType":"181","messageId":"185","endLine":131,"endColumn":38},{"ruleId":"183","severity":1,"message":"184","line":131,"column":67,"nodeType":"181","messageId":"185","endLine":131,"endColumn":69},{"ruleId":"183","severity":1,"message":"184","line":131,"column":98,"nodeType":"181","messageId":"185","endLine":131,"endColumn":100},{"ruleId":"167","replacedBy":"198"},{"ruleId":"169","replacedBy":"199"},"no-native-reassign",["200"],"no-negated-in-lhs",["201"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","use-isnan","Use the isNaN function to compare with NaN.","BinaryExpression","comparisonWithNaN","eqeqeq","Expected '===' and instead saw '=='.","unexpected","Expected '!==' and instead saw '!='.","no-redeclare","'errorMessage' is already defined.","redeclared","no-array-constructor","The array literal notation [] is preferable.","NewExpression","preferLiteral","no-mixed-operators","Unexpected mix of '||' and '&&'.","LogicalExpression","unexpectedMixedOperator",["200"],["201"],"no-global-assign","no-unsafe-negation"]